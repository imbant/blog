<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>关于 js 文件上传 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于 js 文件上传</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于 js 文件上传</h1><div class="post-meta">2019-10-10</div><div class="post-content"><h1 id="有关在-js-中读取文件"><a href="#有关在-js-中读取文件" class="headerlink" title="有关在 js 中读取文件"></a>有关在 js 中读取文件</h1><p>梳理一下最近学到的 js 读取文件的相关知识，如有疏漏，请不吝赐教！<br>源码请见 index.js 与 index.html</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications">MDN-在 web 应用程序中使用文件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696">廖雪峰-JavaScript 教程-操作文件</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/amandakelake/blog/issues/40">JS 文件：读取与拖拽、转换 bsae64、预览、FormData 上传、七牛上传、分割文件</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34291688">知乎专栏-踩坑篇–使用 fetch 上传文件</a>（content-type 为 multipart/form-data 时的坑）</li>
</ul>
<h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><ul>
<li>base64 格式</li>
<li>MIME 类型</li>
<li>HTTP 头部的 Content-Type</li>
<li>FormData 方法</li>
<li>Data URLs</li>
<li>Blob 与 File 对象</li>
<li>FileReader 对象</li>
<li>input 标签： type=file</li>
</ul>
<h2 id="流程概述："><a href="#流程概述：" class="headerlink" title="流程概述："></a>流程概述：</h2><p>基本流程会与相关概念的顺序相反，自顶向下介绍流程。</p>
<h3 id="本地获取文件信息："><a href="#本地获取文件信息：" class="headerlink" title="本地获取文件信息："></a>本地获取文件信息：</h3><p>首先，HTML 里的文件读写需要通过 <code>input</code> 标签实现。我们新建一个：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test-file-upload&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样 UI 上用户就可以点击上传按钮选择文件了。我们可以获取这个文件的文件名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test-file-upload&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fileInput.value); <span class="comment">// 文件名</span></span><br></pre></td></tr></table></figure>

<p>HTML5 开始，新的 File API 允许 js 读取文件内容，获得更多文件信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> file = fileInput.files[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">console</span>.log(file) <span class="comment">// file: File</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上边的代码可以拿到文件对应的 <code>File</code> 对象。要想读取其中的信息，需要用到 <code>FileReader</code> 对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fileInput.addEventListener(<span class="string">&quot;change&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(file); <span class="comment">// file: File</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reader 读取 File 对象是一种请求。当读取完成，会触发 load 事件，</span></span><br><span class="line">  <span class="comment">// 并把 reader.result 设定为读取到的值</span></span><br><span class="line">  reader.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reader.result);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 规定一个读取 File 对象的方法并执行，这里将其解析为 DataURL</span></span><br><span class="line">  reader.readAsDataURL(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，我们就把 <code>File</code> 对象解析成 <code>DataURL</code> 格式的<strong>字符串</strong>了。由于文件是图片，自动将其转码为 base64 格式。<code>DataURL</code> 基本的格式如下：</p>
<blockquote>
<p>data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD…<br>（后边全是 bse64 编码）</p>
</blockquote>
<p>有了 <code>DataURL</code>，就可以实现上传文件之后的预览功能：这个字符串是可以写入 <code>img</code> 标签的 src 被解析的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;preview-img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> previewImg = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;preview-img&#x27;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">reader.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reader.result);</span><br><span class="line">  previewImg.src = reader.result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>根据 <code>DataURL</code> 的定义，在 <code>&#39;base64,&#39;</code> 后边的字符串就是图片的编码了。将它们发送给服务器，再用 base64 解码即可得到原始文件的二进制内容。<br>具体到代码，就是在读取完毕文件（load）后，就可以发送结果了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader 读取 File 对象是一种请求。当读取完成，会触发 load 事件，并把 reader.result 设定为读取到的值</span></span><br><span class="line">reader.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reader.result);</span><br><span class="line">  previewImg.src = reader.result;</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">&quot;example.com&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">body</span>: reader.result, <span class="comment">// <span class="doctag">TODO:</span> 这里还是 DataURL，需要视接口进行格式转换</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;成功发送请求:&quot;</span>, data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上就是基本的本地获取用户上传文件内容的相关代码了。</p>
<p>下一步，考虑如何将 Base64 转码，并向服务器正确发送请求。</p>
<h3 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h3><p>假设后端接口如下：</p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers:"></a>Headers:</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数值</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>multipart/form-data</td>
</tr>
</tbody></table>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body:"></a>Body:</h3><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td>文件</td>
</tr>
</tbody></table>
<p>先解释一下 <code>multipart/form-data</code> 这个 <code>Content-Type</code>：<br>在原生 HTML - js 体系中，上传文件是在 <code>form</code> 标签中实现的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的 <code>enctype</code> 必须指定为 <code>multipart/form-data</code>，<code>method</code> 必须指定为 <code>post</code>，浏览器才能正确编码并以 <code>multipart/form-data</code> 格式发送表单的数据。</p>
<p>在现代前端框架中，为了实现文件上传，必须模拟这个效果，因此引入 <code>FormData</code> 对象。<br><code>FormData</code> 接口提供了一种表示表单数据的键值对的构造方式,模拟一份要发给服务器的表单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  reader.readAsDataURL(file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="comment">// 为 formData 对象添加一个 key-value 对。</span></span><br><span class="line">  <span class="comment">// &#x27;file&#x27; 为表单名称，与接口中 Body 的参数 file 对应</span></span><br><span class="line">  <span class="comment">// 注意 append 第三个参数，可参考 mdn 文档。</span></span><br><span class="line">  formData.append(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">  fetch(<span class="string">&#x27;https://example.com&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 注意这里不用写 content-tpye，原因见下文</span></span><br><span class="line">    <span class="comment">// headers:&#123;&#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;&#125;,</span></span><br><span class="line">    <span class="attr">body</span>: formData,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功发送请求:&#x27;</span>, data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里有一个坑：<code>fetch</code> 方法里没有配置 <code>content-type</code>，这里的原因是：<code>FormData()</code> 模拟了一份数据表单，会自动设置 <code>content-type</code>，事实上，自动设置的 <code>content-type</code> 里不只有 <code>multipart/form-data</code> 这个值，还设置了一个 <code>Boundary</code>。找了一张知乎<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34291688">柳兮</a>小姐姐的截图：<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/3/%E5%85%B3%E4%BA%8E-js-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A01.jpg"></p>
<p>可以看到，Headers 中已经有一个 <code>content-type</code> 了（第一行）。<code>multipart/form-data</code> 后边多了一个 <code>Boundary</code>。这个值是一个标示分界线的作用，可以看到 <code>Request Payload</code> 源码里有几个相同的字符串，这些的作用就和写文章的分割线一样，把 Body 分成好几个部分，每个部分对应一个 <code>form</code> 表单的字段。值得注意的是，在每个部分中都有新定义的 <code>content-disposition</code> 和 <code>content-type</code> 这些「本该」出现在 Headers 里的字段，这些都是服务器用于分段解析 Body 的。</p>
<p>再回头看 <code>fetch</code>，如果在里边手动写上 <code>content-type</code>，就会用空白覆盖掉自动设置的 <code>Boundary</code>，服务器是要抛出 500 并报错的：</p>
<blockquote>
<p>Error: Multipart: Boundary not found</p>
</blockquote>
<h4 id="有几句后话："><a href="#有几句后话：" class="headerlink" title="有几句后话："></a>有几句后话：</h4><p>由于后端接口接受一个 File 对象，前边用 FileReader 将 File 转为 DataURL 似乎没啥卵用（除了能预览文件），但却并没有用到当时写好的 fetch 请求。事实上，前边转码还是有意义的：读取到代表文件内容的信息，就可以做一些相关操作，例如给用户上传的图片加上水印后，才发送给后端储存。这种需求就需要对 DataURL 做操作（借助 canvas 等），以得到一份加了水印的文件。当然，如果后端接口仍然是接收一个 File 对象，则需要将加好水印的 DataURL 再转换为 File 对象，然后发送上传图片请求。<br>在将 DataURL 转换为 File 对象时也有个坑：<br>可以使用 fetch 访问 DataURL（从语义上，这就是 URL 的功能了：可以直接写在 img 的 src 里，也可以被 fetch）。但这种做法会有些数据损失：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reader.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetch(reader.result <span class="keyword">as</span> string)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.blob())</span><br><span class="line">    .then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里 fetch 到的结果是 Blob 对象，而不是 File 对象</span></span><br><span class="line">    <span class="comment">// 两者很相似，File 比 Blob 多两个字段：name 和 lastModifiedDate</span></span><br><span class="line">    <span class="comment">// 也就是说，在 File -&gt; DataURL -&gt; Blob 的过程中，文件数据有两个字段的损失</span></span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/blog/tags/JS/"><i class="fa fa-tag"></i>JS</a></div><div class="post-nav"><a class="pre" href="/blog/2019/11/19/flex-box-%E4%B8%8B%E7%9A%84%E5%AE%BD%E5%BA%A6%E9%97%AE%E9%A2%98/">flex box 下的宽度问题</a><a class="next" href="/blog/2019/09/11/Token-Session-Cookie/">Token Session Cookie</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>