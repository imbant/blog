<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>同源策略与跨域 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">同源策略与跨域</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">同源策略与跨域</h1><div class="post-meta">2021-10-22</div><div class="post-content"><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略限制了一个源的 document 和 script 如何与另一个源交互。<br>源是指<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>，同源指两个 URL 的源相同</p>
<p>同源策略主要限制以下三种操作</p>
<h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><p>首先要知道，在浏览器打开两个网页（标签/窗口），在同源时是可以相互交互的：<br>以本博客首页为例：源都为 <code>https://imbant.github.io/</code>，在首页 <code>/blog/</code> 打开控制台，调用 <code>window.open</code> 打开 <code>/blog/archives/</code> 到归档，可见：<br><code>window.open</code> 会返回被打开页面的 <code>Window</code> 对象，而被打开的页面 <code>window.opener</code> 指向前一个页面的 <code>Window</code> 对象。<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/12/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%882.23.23.png"></p>
<p>这两个暴露在其他页面的 Window 对象，是可以正常访问，执行内部方法并影响到真正的页面的：<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/12/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%882.29.35.png"></p>
<p>因此可以进行 DOM 操作：<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/12/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%882.30.53.png"></p>
<p>非常危险的操作。试想如果没有同源限制，打开一个钓鱼网站和银行官网，钓鱼网站可以随意获取账号密码信息。</p>
<p>这类允许文档间直接相互引用的 API，有 </p>
<ul>
<li><code>window.open()</code> 返回被打开的 Window</li>
<li><code>window.opener</code> 返回打开当前窗口的那个 Window</li>
<li><code>window.parent</code> 返回当前窗口的父 Window，如果当前窗口是一个 <code>&lt;iframe&gt;</code>， <code>&lt;object&gt;</code>， 或者 <code>&lt;frame&gt;</code>，则它的父 Window 是嵌入它的那个 Window</li>
<li><code>iframe.contentWindow</code> 返回 iframe 的 Window</li>
</ul>
<p>在实际操作中，浏览器提供了 <code>window.postMessage</code> 来<em>更安全</em>的实现跨域的跨文档消息机制</p>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>无法访问不同源页面的 <code>cookie</code> <code>indexDB</code> <code>localStorage</code></p>
<h3 id="XMLHttpRequest-操作"><a href="#XMLHttpRequest-操作" class="headerlink" title="XMLHttpRequest 操作"></a>XMLHttpRequest 操作</h3><p>普遍情况下，XHR 请求只可以对同源站点</p>
<h2 id="XHR-跨域"><a href="#XHR-跨域" class="headerlink" title="XHR 跨域"></a>XHR 跨域</h2><p>为了安全性，XHR 需要牺牲便利性，来发起跨域请求。</p>
<h3 id="CORS-Cross-Orign-Resource-Sharing"><a href="#CORS-Cross-Orign-Resource-Sharing" class="headerlink" title="CORS(Cross-Orign Resource Sharing)"></a>CORS(Cross-Orign Resource Sharing)</h3><p>CORS 是一个 W3C 标准，由一些 HTTP 头组成，可以让前后端共同配置，实现跨域 XHR 请求。</p>
<p>有两种场景：简单请求和预检请求</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>简单请求需要满足：</p>
<ul>
<li>方法只能为 <code>GET</code>、<code>HEAD</code>、<code>POST</code>。其中 <code>HEAD</code> 用于只请求 header，并且这个 header 会和 <code>GET</code> 请求中的一样，用于下载大文件前提前了解大小，节省带宽。</li>
<li>除了默认 header 之外，只可以有以下 header<ul>
<li><code>Accept</code> response 可选的 <code>MIME</code> 类型</li>
<li><code>Accept-Language</code> 指定客户端可以理解的自然语言</li>
<li><code>Content-Language</code> 指定用户（audience）希望的自然语言</li>
<li><code>Content-Type</code></li>
<li>还有一些头 TODO:</li>
</ul>
</li>
<li><code>Content-Type</code> 只能为三者之一<ul>
<li><code>application/x-www-form-urlencoded</code> 通过 ‘&amp;’ 和 ‘=’ 连接的键值对</li>
<li><code>multipart/form-data</code> 表格类型</li>
<li><code>text/plain</code> 原始文本</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Content Type</code> 的限制是为了兼容表单（form），历史上表单一直是可以跨域请求的。同时 <code>&lt;form&gt;</code> 标签的 <code>enctype</code> 属性也是这三者之一，用以标识原生表单 POST 时的 Content Type，表单不借助 js 天然就可以发出简单请求</p>
</blockquote>
<p>对于简单请求，浏览器直接发出 XHR 请求，并在 header 中加入 <code>Origin</code> 字段，来标识本次请求的源（协议、域名、端口）。<br>服务端收到这个跨域 request，并且在许可的源范围内，response 中就会三个头：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code> 这个字段是必须的，否则会视为跨域请求失败。值为 request 时的 Origin 或者 ‘*’</li>
<li><code>Access-Control-Allow-Credentials</code> 可选，如果为 true 表示服务端明确许可 request 中带 Cookie，并且前一个 header <code>Access-Control-Allow-Origin</code> 不能为 ‘*’，必须写明源</li>
<li><code>Access-Control-Expose-Headers</code> 指定客户端可以访问的 response 的 header，例如 response 中服务端自定义 header <code>X-Customer-Header</code>，需要指定后客户端才能在 XHR 请求对象中拿到，否则只能拿到一些基础 header TODO: 感觉很鸡肋啊，就算 JS 脚本拿不到，抓包还是能拿到没指定的 header</li>
</ul>
<blockquote>
<p>XMLHttpRequest 对象的请求默认不带 cookie，需要手动设置 withCredentials = true</p>
</blockquote>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>不符合简单请求的被称为预检（preflight）请求。<br>浏览器发现 XHR 请求需要预检，会先发送一个 <code>OPTION</code> 请求到服务端，这个请求不会对服务器资源产生影响。</p>
<blockquote>
<p>用 OPTION 做预检的原因在于，节省服务端处理跨域请求的资源</p>
</blockquote>
<p>预检会带上以下 header</p>
<ul>
<li><code>Origin</code></li>
<li><code>Access-Control-Request-Method</code> 告知实际请求的 method</li>
<li><code>Access-Control-Request-Headers</code> 告知实际请求携带的自定义 header</li>
</ul>
<p>服务端确认允许跨域后，会对预检做出 response，带上 CORS header</p>
<ul>
<li><code>Access-Control-Allow-Origin</code> 同简单请求</li>
<li><code>Access-Control-Allow-Credentials</code> 同简单请求</li>
<li><code>Access-Control-Allow-Methods</code> 允许客户端使用的 method，会返回全部支持的 method，不限于预检的，避免多次预检</li>
<li><code>Access-Control-Allow-Headers</code> 允许客户端携带的 header，会返回全部支持的 method，不限于预检的，避免多次预检</li>
<li><code>Access-Control-Max-Age</code> 预检有效时间，在有效时间内发跨域请求无需再次预检</li>
</ul>
<p>通过预检后，浏览器正常的 CORS 请求都会和简单请求一样，带上 <code>Origin</code>，服务端也会每次回应 <code>Access-Control-Allow-Origin</code></p>
<blockquote>
<p>注意跨域请求失败的情况下，一般 response 状态码可能为 200，而 CORS 需要的 header 不存在，通过 header 感知跨域失败</p>
</blockquote>
<table>
<thead>
<tr>
<th>简单请求 request</th>
<th>简单请求 response</th>
<th>OPTION request</th>
<th>OPTION response</th>
</tr>
</thead>
<tbody><tr>
<td><code>Origin</code></td>
<td><code>*-Allow-Origin</code> <br /> <code>*-Allow-Credentials</code> <br /> <code>*-Expose-Headers</code></td>
<td><code>Origin</code> <br /> <code>*-Request-Method</code> <br /> <code>*-Request-Headers</code></td>
<td><code>*-Allow-Origin</code> <br /> <code>*-Allow-Credentials</code> <br /> <code>*-Allow-Method</code> <br /> <code>*-Allow-Headers</code> <br /> <code>*-Max-Age</code></td>
</tr>
</tbody></table>
<p>* 表示 <code>Access-Control</code> 前缀，方便排版</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>JSONP：通过在 HTML 手动插入 <code>&lt;script&gt;</code> 标签，利用其加载资源无跨域限制的方式发送跨域请求。一般是前端全局定义一个函数，然后被请求的服务端返回一段 js 代码，去执行这个函数，并把需要的数据传给参数。缺点是只可以做 GET 请求，代码侵入性大。</p>
<p>本地调试时正向代理 - 服务端不知道真正发请求的客户端：node 服务转发、webpack 本地配置 devServer proxy（部署时是同源的）、Charles 代理</p>
<p>线上部署时反向代理 - 客户端不知道真正接收请求的服务端：nginx 负载均衡，客户端请求的是负载均衡服务器，由他转发请求到不同源</p>
<p>window.postMessage：见上文，更安全更受控的跨文档通信方式</p>
</div><div class="tags"><a href="/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"><i class="fa fa-tag"></i>浏览器</a></div><div class="post-nav"><a class="pre" href="/blog/2022/01/26/HTML-attribute-%E4%B8%8E-DOM-property-%E8%AF%A6%E8%A7%A3/">DOM property 与 attribute 详解</a><a class="next" href="/blog/2021/10/02/ES6%20%E5%90%88%E9%9B%86/">ES6 合集</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script></div></body></html>