<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="imbant 前端工程师技术博客"><meta name="keywords" content="前端,imbant,技术博客,浏览器,Electron,React,Vue,Node,Webpack,Vite,Chrome"><title>ES6 合集 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6 合集</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6 合集</h1><div class="post-meta">2021-10-02</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-number">1.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%9A%84-key"><span class="toc-number">1.2.</span> <span class="toc-text">唯一的 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84-Symbol-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">遍历对象中的 Symbol 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%9A%84-value"><span class="toc-number">1.4.</span> <span class="toc-text">唯一的 value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%90%8C%E4%B8%80%E4%B8%AA-Symbol-%E5%80%BC"><span class="toc-number">1.5.</span> <span class="toc-text">获取同一个 Symbol 值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E4%B8%8E-Set"><span class="toc-number">2.</span> <span class="toc-text">Map 与 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">2.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">2.2.</span> <span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E4%B8%8E-for-of-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.</span> <span class="toc-text">Iterator 与 for of 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.</span> <span class="toc-text">迭代器(Iterator)协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">可迭代协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">迭代协议的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E2%80%A6of%E3%80%81for%E2%80%A6in%E3%80%81Array-prototype-forEach%E3%80%81for-await%E2%80%A6of"><span class="toc-number">4.</span> <span class="toc-text">for…of、for…in、Array.prototype.forEach、for await…of</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E2%80%A6in"><span class="toc-number">4.1.</span> <span class="toc-text">for…in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-prototype-forEach"><span class="toc-number">4.2.</span> <span class="toc-text">Array.prototype.forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E2%80%A6of"><span class="toc-number">4.3.</span> <span class="toc-text">for…of</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-number">5.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-number">6.</span> <span class="toc-text">class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es-module"><span class="toc-number">7.</span> <span class="toc-text">es module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">Generator 函数</span></a></li></ol></div></div><div class="post-content"><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>从语言层面提供一种不会重复的唯一性的值，而不关心具体的值是什么。</p>
<p><code>Symbol</code> 函数可以创建 Symbol 值，调用两次函数，会得到两个不同的值。<br>入参可以为字符串，用以在调试时控制台输出时更<em>可读</em>。但即使用同一个字符串创建两个 Symbol，其值也是<strong>不同</strong>的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>()      <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>()      <span class="comment">// Symbol()</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>)   <span class="comment">// Symbol(x)</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>)   <span class="comment">// Symbol(x)</span></span><br><span class="line">c === d <span class="comment">// false，x 只是对值的描述，而非真的值</span></span><br></pre></td></tr></table></figure>

<p>Symbol 值是基本数据类型而非对象，创建时也不应该用 <code>new</code> 关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError，Symbol 不是构造函数</span></span><br></pre></td></tr></table></figure>

<p>Symbol 可以转为 string 和 boolean</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sb = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(sb)     <span class="comment">// &#x27;Symbol(s)&#x27;</span></span><br><span class="line">sb.toString()  <span class="comment">// &#x27;Symbol(s)&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!sb   <span class="comment">// false</span></span><br><span class="line">!!sb  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="唯一的-key"><a href="#唯一的-key" class="headerlink" title="唯一的 key"></a>唯一的 key</h3><p>对象的 key 使用 Symbol 命名，可以保证唯一性，避免被不小心覆盖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>() <span class="comment">// 以下三种方法等价</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[symbolKey] = <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [symbolKey]: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, symbolKey, &#123;<span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>取值时需要用方括号，否则会被当作一个 string 的 key</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[symbolKey] <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历对象中的-Symbol-属性"><a href="#遍历对象中的-Symbol-属性" class="headerlink" title="遍历对象中的 Symbol 属性"></a>遍历对象中的 Symbol 属性</h3><p>Symbol 作为对象的 key 时，<strong>不会</strong>被 <code>for in</code> <code>for of</code> <code>Object.keys()</code> <code>Object.getOwnPropertyNames()</code> <code>JSON.stringify</code> 遍历到。</p>
<p><code>Object.getOwnPropertySymbols</code> 可以得到对象中所有用作 key 的 Symbol</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">a[s] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key) <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(a) <span class="comment">// [Symbol(key)]</span></span><br></pre></td></tr></table></figure>

<h3 id="唯一的-value"><a href="#唯一的-value" class="headerlink" title="唯一的 value"></a>唯一的 value</h3><p>例如要维护一个 local storage 的 key，保证唯一性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageKey = &#123;</span><br><span class="line">    <span class="attr">key1</span>: <span class="string">&#x27;key1&#x27;</span>, <span class="comment">// 这个 value 值本身其实是无意义的，只会用来判断唯一性，而且编码时需要人工确认 value 唯一</span></span><br><span class="line">    <span class="attr">key2</span>: <span class="string">&#x27;key2&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 value 就可以换为 Symbol，来移除这些无意义的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageKey = &#123;</span><br><span class="line">    <span class="attr">key1</span>: <span class="built_in">Symbol</span>(),</span><br><span class="line">    <span class="attr">key2</span>: <span class="built_in">Symbol</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取同一个-Symbol-值"><a href="#获取同一个-Symbol-值" class="headerlink" title="获取同一个 Symbol 值"></a>获取同一个 Symbol 值</h3><p>Symbol 提供了一个全局的登记机制，来实现重新使用同一个 Symbol 值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&#x27;key1&#x27;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&#x27;key1&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;key2&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;key2&#x27;</span>)          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code> 与 <code>Symbol()</code> 的不同在于，<code>Symbol()</code> 无论入参是什么都会返回一个全新的 Symbol，而 <code>Symbol.for()</code> 会检查对应的 key 是否已经被登记，登记了就返回同一个 Symbol，否则新建一个 Symbol。</p>
<p><code>Symbol.keyFor()</code> 返回一个已经登记过的 Symbol 的 key</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s) <span class="comment">// &#x27;key&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于这个全局机制，在不同作用域下登记过的 key，都会被全局记录下来，不分作用域，可以用在不同的 iframe 或者 service worker 中取同一个 Symbol。</p>
<h2 id="Map-与-Set"><a href="#Map-与-Set" class="headerlink" title="Map 与 Set"></a>Map 与 Set</h2><p><code>Object</code> 是一种键值对的结构，但 key 只能是 <code>String</code> 或者 <code>Symbol</code>。作为扩展，出现了可以用任何数据类型作为 key 的键值对结构：Map</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>通过 set、get、has 来读写值，通过 clear 清空，通过 size 得到大小，array-like</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a.set(obj, <span class="number">1</span>)</span><br><span class="line">a.get(obj)      <span class="comment">// 1</span></span><br><span class="line">a.has(obj)      <span class="comment">// true</span></span><br><span class="line">a.size          <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a.set(obj, <span class="number">2</span>)</span><br><span class="line">a.get(obj)      <span class="comment">// 2，会被覆盖，key 是唯一的</span></span><br></pre></td></tr></table></figure>

<p>与 Object 的区别：</p>
<ol>
<li>Map 的 key 可以是任意数据类型</li>
<li>Map 实现了可迭代协议，可以被 <code>for..of</code> 这样的语法迭代</li>
<li>Map 是<strong>有序</strong>的，迭代时会按照 set 的顺序遍历元素</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>与 <code>Map</code> 相比，<code>Set</code> 是值的集合，没有 <code>key</code> 的概念。但 <code>Set</code> 会保证集合里的值都是唯一的，不会重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">a.add(<span class="number">1</span>)</span><br><span class="line">a.has(<span class="number">1</span>)  <span class="comment">// true</span></span><br><span class="line">a.add(<span class="number">3</span>)</span><br><span class="line">a.size    <span class="comment">//  2</span></span><br><span class="line">a.add(<span class="number">1</span>)</span><br><span class="line">a.size    <span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p><code>Set</code> 同样可以迭代，迭代时<strong>有序</strong></p>
<p>通过构造函数，<code>Set</code> 可以用于数组去重：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> b = [...new <span class="built_in">Set</span>(a)]</span><br></pre></td></tr></table></figure>

<h2 id="Iterator-与-for-of-循环"><a href="#Iterator-与-for-of-循环" class="headerlink" title="Iterator 与 for of 循环"></a>Iterator 与 for of 循环</h2><p>JS 表示「集合」概念的数据结构，有 <code>Array</code> <code>Object</code> <code>Map</code> <code>Set</code>。以下的迭代（iterate）协议定义了他们的迭代行为，可以理解为如何「遍历」这些集合。</p>
<h3 id="迭代器-Iterator-协议"><a href="#迭代器-Iterator-协议" class="headerlink" title="迭代器(Iterator)协议"></a>迭代器(Iterator)协议</h3><p>考虑对数组的遍历，需要两个状态：1. 当前迭代的值，2.迭代是否结束。<br>一个对象需要实现一个 <code>next()</code> 属性，才能成为迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="number">1</span>,    <span class="comment">// 当前迭代的值</span></span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span>  <span class="comment">// 迭代是否结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以通过调用 <code>iterator.next()</code> 的方式来遍历，直到 done 为 <code>true</code>（也可以永远是 <code>false</code>，无限长）</p>
<h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>一些语法和 API 需要可迭代对象： </p>
<ul>
<li><code>for...of</code> <code>...展开语法</code> <code>yield*</code> <code>解构赋值</code></li>
<li><code>new Map([iterable])</code> <code>new Set([iterable])</code> <code>Promise.all(iterable)</code> <code>Promise.race(iterable)</code> <code>Array.from(iterable)</code></li>
</ul>
<p>可迭代对象需要实现 <code>[Symbol.iterator]</code> 函数，这个函数无参数，返回一个迭代器。其中 <code>Symbol.iterator</code> 是 Symbol 内置的11个值之一，这些内置值都指向语言内部使用的方法<br>可以用 TS 来描述这三种类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">interface</span> Iteratorable &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator](): Iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">interface</span> Iterator &#123;</span><br><span class="line">    next(): IterationResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代结果</span></span><br><span class="line"><span class="keyword">interface</span> IterationResult &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">any</span>,</span><br><span class="line">    <span class="attr">done</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代协议的应用"><a href="#迭代协议的应用" class="headerlink" title="迭代协议的应用"></a>迭代协议的应用</h3><p>原生可迭代对象如下，这些对象都可迭代，比如放入 <code>for...of</code> 语句中</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String <strong>可以特别注意下，字符串是可迭代的</strong></li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>调用 Array 的 <code>[Symbol.iterator]</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrIterator = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">arrIterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">arrIterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">arrIterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">arrIterator.next() <span class="comment">// &#123; value: undefined , done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>原生的 Object 是不可迭代的，需要开发者手动定义对象被遍历时的行为。<br>可以自定义一个类似 Array 的对象，用 Array 的 <code>[Symbol.iterator]</code> 函数，在 <code>for..of</code> 中表现出 Array 的特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of、for…in、Array-prototype-forEach、for-await…of"><a href="#for…of、for…in、Array-prototype-forEach、for-await…of" class="headerlink" title="for…of、for…in、Array.prototype.forEach、for await…of"></a>for…of、for…in、Array.prototype.forEach、for await…of</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p>为遍历对象的属性而构建。会遍历对象<strong>和原型链</strong>上的可枚举属性。相应的 <code>Object.keys</code> <code>Object.getOwnPropertyNames</code> 只会遍历对象自身的可枚举属性，不管原型链。<br>因此<strong>不应该</strong>用于遍历 Array ：</p>
<ul>
<li>会遍历到数组上手动添加的属性，而不只是 index；</li>
<li>不能保证遍历顺序；</li>
<li>只能得到 index，还需要手动取 value<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.foo = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.newName = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="comment">// 0, 1, 2, &#x27;foo&#x27;, &#x27;newName&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h3><p>是数组内部提供的遍历函数。缺点在于无法 <code>break</code> 和 <code>continue</code></p>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>比起 <code>for...in</code>，基于可扩展的协议，扩展性更好</p>
<p>对象必须定义了迭代方式 <code>[Symbol.iterator]</code> 才能迭代</p>
<p>Array 的迭代协议：针对 <code>for...in</code> 的缺点，Array 的迭代协议：</p>
<ul>
<li>不会迭代到手动添加的属性</li>
<li>会遍历 value 而不是 index<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">arr.foo = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="comment">// 0, 1, 2, &#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h2 id="es-module"><a href="#es-module" class="headerlink" title="es module"></a>es module</h2><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2></div><div class="tags"><a href="/blog/tags/JS/"><i class="fa fa-tag"></i>JS</a></div><div class="post-nav"><a class="pre" href="/blog/2021/10/22/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F/">同源策略与跨域</a><a class="next" href="/blog/2021/09/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%B8%8E%E5%AE%9E%E7%8E%B0/">前端性能监控指标与实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>