---
title: JS 事件循环
date: 2020-04-13 14:31:08
tags: [JS]
---

摘自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)

JS 有一个基于**事件循环**的并发模型。事件循环负责执行代码、收集和处理事件，以及执行队列中的子任务。

## 运行时（Runtime）概念

![](/blog/images/JS-事件循环.svg)

### 栈

函数调用形成了一个由若干帧组成的栈。

```js
function foo(b) {
  let c = b * 3;
  return c;
}

function bar(a) {
  let y = a + 1;
  return foo(y);
}

console.log(bar(3));
```

调用`bar`时，创建第一个帧，包含了`bar`的参数和本地变量（a、y），这个帧被 push 入栈。在`bar`调用`foo`时，创建第二个帧，包含了`foo`的参数和本地变量(b,c)，这个帧也被 push 入栈（且在第一个帧的上边）。`foo`执行完毕后，第二帧被 pop 出栈，同理`bar`执行完毕第一帧也被 pop 出栈。

### 堆

对象被分配在*堆*中，*堆*是一个用来表示一大块（通常是非结构化的）**内存区域**的术语。

### 消息队列

运行时包含了一个待处理消息的消息队列。其中每个`消息`都关联一个用以处理这个消息的回调`函数`。

事件循环期间的某个时刻，运行时会按照队列顺序，从最先进入的开始处理队列中的`消息`。被处理的消息会被移除队列，并作为输入参数来调用与之关联的`函数`。调用一个函数总是会为其创造一个新的`栈`帧。

函数处理会一直进行到执行栈空再次为空为止。然后事件循环就开始处理队列中的下一个消息。

## 事件循环

之所以称之为**事件循环**，是因为它经常以下面的方式被实现：

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

一种死循环一样的机制。`queue.waitForMessage()`会*同步*等待消息到达。所谓消息应该可以理解为代码段或函数。

### “执行至完成”

每个消息完整执行后，其他消息才会被执行。这位程序分析提供了优秀的特性，包括：当一个函数执行时，它不会被抢占，只有它运行完毕后才会去运行其他代码，才能修改这个函数操作的数据。这与 C 不同，函数在线程中运行，它可能在任何位置被终止，然后在另一个线程中运行其他代码。

这个模型的缺点在于当一个消息需要太长时间才能处理完毕时，应用就无法处理用户交互，例如点击、滚动事件。为了缓解这个问题，应该缩短单个消息处理时间，并在可能的情况下将一个消息剪裁成多个消息。

### 添加消息

在浏览器中，如果一个事件发生，并且这个事件绑定了监听器（`addEventListener`），就会在消息队列中添加一个消息。

对于`setTimeout`这个函数，它接收两个参数：待加入消息队列的消息（函数）和一个时间值。这个事件代表被加入到消息队列的*最小延迟时间*。如果消息队列中没有其他消息且栈为空，在这段延迟过去后消息就会被马上处理。但是如果队列中还有其他消息，`setTimeout`的消息必须等其他消息处理完。
因此第二个参数仅仅表示最小延迟，而非*确切*的等待时间。
注意，`setTimeout`函数本身会比其参数函数优先执行，也就是优先进入消息队列；同时`setTimeout`本身也是异步的，所以也得等消息队列没有其他消息才会执行这个函数。

下面的例子演示了最小延迟时间的概念：

```js
const now = new Date().getSeconds();

const getTimeGap = () => new Date().getSeconds() - now;

setTimeout(() => {
  console.log(getTimeGap());
}, 500);

setTimeout(() => {
  console.log(getTimeGap());
}, 3000);

while (true) {
  if (getTimeGap() >= 2) {
    console.log("时间间隔大于 2s");
    break;
  }
}
```

输出如下：

```text
// 2秒后
时间间隔大于 2s
2 // 来自第一个 setTimeout

// 3秒后
3 // 来自第二个 setTimeout
```

在这个作用域中，消息队列一直被 while 死循环产生的消息占满，直到时间间隔超过 2 秒，循环结束，消息队列才能处理第一个`setTimeout`发来的消息，由于时间已经超过其最小延迟（500ms），消息被立即执行。接着处理第二个`setTimeout`，1 秒后达到它的最小延迟（3000ms）,执行它的消息。

### 零延迟

`setTimeout`的延迟设置为 0 并不表示消息会立即执行。

其等待时间仍然由队列里待处理消息的数量决定，即使轮到这个消息执行时，时间已经超过了最小延迟。

```js
console.log(1);
setTimeout(() => console.log(2));
console.log(3);
setTimeout(() => console.log(4));
console.log(5);

// 1
// 3
// 5
// 2
// 4
```
