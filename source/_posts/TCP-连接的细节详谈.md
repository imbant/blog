---
title: TCP 连接的细节详谈
date: 2020-03-24 15:55:08
tags: [TCP]
---

谈一谈 TCP 解决了什么问题，以及三次握手、四次挥手的细节，包括传输无误的流程以及每个环节出错的情况

## 数据传输过程

在 TCP/IP 四层模型里，TCP 接收来自应用层的数据流，将其分割并封装为适当长度的 TCP 「报文」，通过 IP 层（网际层）传输数据。

TCP 是可以可靠传输数据的，也就是说，建立 TCP 连接的双方，能保证发出的信息一定被接收到。如何实现这一点呢？

- 首先，TCP 的报文是按顺序发送的，且 TCP 会对报文中包含的数据的**每个 Byte**做编号。假设报文的数据序号从 1 开始（实际上起始序号可变，原因见下文 ），第 ① 段报文包含 1460 Byte 字节，其中每个 Byte 的编号就是 1，2，3，...，1460。
- 发送给接收端，接收端收到报文后，用一段不携带数据的 TCP 报文（相当于只有报文头）确认，同时用确认号 1461（1460 + 1）来表示，自己受到了前 1460 Byte 的数据。
- 接着，发送端发送第 ② 段报文，数据长度也为 1460 Byte，这样数据编号就变成 1461，1462，1463，...，2920.
- 接收端收到报文后，确认的报文确认号就为 2921（2920 + 1）。
- 如此往复...显然，接收端无需每次都回复，比如他收到 ①~⑤ 条报文段，由于报文段按顺序发送的缘故，只需要确认第 ⑤ 段即可。
- 如果一共发送了五段报文，第 ③ 段接收端还没有收到，就收到了 ④、⑤ 段，说明第 ③ 段传输失败了。因此接收端只能确认收到第 ② 段。
- 发送端得知最后一个未被确认的包是第 ③ 段，重传它。成功接收后，接收端就可以直接确认 ⑤ 段，因为 ④ ⑤ 已经收到。

![](/blog/images/TCP-连接的细节详谈1.gif)

TCP 标识了报文数据的顺序，从而接收端接收数据时可以重建顺序。关于上文说到的，在接收到一定量的连续字节流后才发送确认，这是一种 TCP 的扩展，被称为选择确认（Selective Acknowledgement）。选择确认使得接收端可以对乱序到达的数据块进行确认。乱序到达可能是因为包的乱序交付(由于网络延迟，第 ② 段报文比第 ① 段先送到），或者丢包。

### 可见，序号是保证可靠性的核心

然而上面的流程中，用 1 作为起始序号有**安全隐患**：第三方如果猜到序号，可以伪造一个 RST 报文，具体危害见这个[回答](https://www.zhihu.com/question/34400902/answer/191928024)。
因此，序号需要动态随机生成（毕竟，从 0 开始猜 SN 和从一个随机数开始猜难度不一样），实际上它是由操作系统随机生成的 32 位长的序号。那么自然的，TCP 通信双方就需要在建立连接时，创建好初始序号，并同步给对方。

现在概念比较多了，我们用一些缩写来代指专有名词，并看看 TCP 报文的数据包接口是否符合需求：
`SN`(sequence number)：序号，序列号，指 TCP 报文携带的数据中每个 Byte 的编号
`ISN`（Initial Sequence Number）：初始的 SN，SN 的起点，在三次握手中同步
`ACK`（Acknowledge）：确认，指接收端收到报文段后根据 SN 回复的行为。ACK 并不意味着数据已经交付了上层应用程序。
`SYN`（synchronization  `/ˌsɪŋkrənaɪˈzeɪʃən/`）：同步，指一端告诉另一端自己的 ISN
`FIN`（finish）：指断开连接

![](/blog/images/TCP-连接的细节详谈2.jpg)

可见：

- **每个**报文段都带有序列号码，也就是 SN，用于标识报文的序号。注意，虽然说 SN 标识的是报文数据中*连续*的 Byte（1000，1001，1002...），但连个连续报文段的 SN 是*不连续*的，前一段可能是 1000，下一段可能就是 1500，也就是说前一段有 500 Byte 的数据。
- **每个**报文段还会带上 ACK number，除了第一次握手的 SYN 报文。
- 报文头中有 9 个标志符，每个占 1 bit。
  - 上述的 ACK、SYN、FIN 三种操作都是通过对应的标识符置 1 来实现的。
  - `RST` = reset，当该位置 1 时，说明有严重差错，需要重新创建 TCP 连接。还可以用于拒绝非法的报文段和拒绝连接请求。
  - 另外 5 种不太懂...

## 三次握手

建立 TCP 连接，首先要做的是客户端和服务端让对方知道自己的 ISN。

下文表述中的发送端和接收端变成客户端和服务端。实际上客户端不一定是发送端，比如建立连接后服务端也可以向客户端发送 TCP 报文。

1. 涉及到两个过程：a.客户端向服务端同步，b.服务端向客户端同步。
2. 理论上两端同时初始化它们之间的连接是可能的，不过大多数情况下都是有先后顺序的：服务端先打开一个 socket 来监听另一端的连接（此时处于`LISTEN`状态）。服务端被被动打开后，客户端就能创建主动打开。
3. 客户端生成 ISN（不妨记为 `x`），放在报文头的 SN 位置。先向服务端发送自己的 ISN，同时在报文头中把 SYN 置 1，向服务端表明这段报文是连接请求。
4. 服务端正确收到报文，在本地保存客户端的 ISN。同时为了保证可靠传输，要向客户端发送 ACK 报文，其 ACK number 为 `x + 1`，以表明自己收到了客户端的 ISN，且值为 x
5. 这样过程 a 就完工了，还有过程 b。
6. 服务端向客户端发送自己的 ISN（不妨记为 `y`），同时在报文头中把 SYN 置 1。
7. 客户端正确收到报文，在本地保存服务端的 ISN。同样是保证可靠传输的原因，向服务端发送 ACK 报文，其 ACK number 为 `y + 1`。**注意**因为第一次 SYN 报文是带了 1 bit 数据的，所以这段报文的 SN 值为 ISN + 1，也就是 `x + 1`。

每次发送报文的过程就成为一次「握手」。可见，服务端向客户端*连续*发送了两次报文，这是没有必要的，降低了传输效率。
上述过程称为「四次握手」，将服务端连续两次的握手合并，就得到了三次握手：

> 1. 客户端发送 SYN 报文，SN = ISN，由`CLOSED`状态转为`SYN-SENT`状态。
> 2. 服务端收到客户端的 SYN 后，向客户端发送 SYN/ACK 报文，带上 ACK number，SN = ISN，由`LISTEN`状态转为`SYN-RCVD`（RCVD = received）状态
> 3. 客户端收到服务端的 SYN/ACK 后，向服务端发送 ACK 报文，带上 ACK number, SN = (ISN + 1)，由`SYN-SENT`转为`ESTABLISHED`状态

![](/blog/images/TCP-连接的细节详谈3.png)

之后，当服务端接收到 ACK，转为`ESTABLISHED`状态，TCP 连接建立成功

### 容错机制

三次握手如何确保双方稳定获取了彼此的 ISN 呢？考虑发送端握手失败的情况：

#### 客户端没收到自己 ISN 的 ACK，得知第一次握手失败

两种可能

- 服务端收到 SYN 了，但 ACK 报文发送失败了：信息似乎同步成功了，只是客户端不知情。
- 服务端根本没收到 SYN：很严重，可靠性受到威胁。

客户端没法判断究竟是哪种情况，必须处理最坏的情况，也就是服务端没收到 ISN。没收到咋办呢？周期性超时重传 SYN。

#### **服务端没收到自己 ISN 的 ACK，得知第二次握手失败**

两种可能

- 客户端收到 SYN，ACK 报文发送失败
- 客户端没收到 SYN

同样的，服务端必须周期性超时重传 SYN/ACK 报文。

但是考虑此时的客户端状态：
客户端发送完 ACK 报文后，就转为 `ESTABLISHED` 状态，单方面认为三次握手成功，准备收发数据了。

> 第三次握手成功与否，或者说服务端是否接收到这次 ACK 报文，客户端是**无感知**的。

此时：

- 服务端会周期性超时重传 SYN/ACK（默认五次），直到正确收到客户端的 ACK，或者超过最大时限，转入`CLOSED`状态
- 客户端如果有数据发送，并成功送达服务端：
  - 服务端已经进入`CLOSED`状态，则会以 RST 报文回应。
  - 服务端还在`SYN_RCVD`状态，服务端会正常收到数据 + 期望中的 ACK number，相当于还是成功接收到 ACK 了，第三次握手成功，服务端也转为 `ESTABLISHED` 状态。

服务端在`SYN_RCVD`和`CLOSED`状态下的行为
![](/blog/images/TCP-连接的细节详谈4.jpeg)
![](/blog/images/TCP-连接的细节详谈5.jpeg)
图片源自《TCP/IP 协议族》

可见，第三次握手中客户端发出的 ACK 是“不可靠的”。这次客户端没能保证自己的信息被服务端成功接收。不过由于第一次 SYN 之外的全部报文中 ACK 都置 1 这个设计，规避了不稳定的隐患。

### 那么需要对第三次握手的 ACK 再做 ACK 吗？

不需要。如果说需要对无数据的报文进行 ACK，则会进入互相 ACK 的死循环：
服务端收到 ACK，如果为了让客户端知道自己收到了 ACK，再次 ACK，客户端又收到 ACK，需要再次 ACK，服务端又 ACK...就没个头了。
所有 ACK 的发送方都不保证 ACK 的可靠性，由对方保证超时重传

**TCP 对有数据的报文必须确认；不会为没有数据的 ACK 超时重传。**
第三次握手的 ACK 报文就没有携带数据。发送出去之后不要求接收方返回 ACK。
此时有个问题，第二次握手的 SYN/ACK 被确认了，它带了什么数据？
TCP 设计者将 SYN 报文设计成占用一个字节的编号（可以理解为“消耗”了一个 SN）（FIN 标志位也是），也就是说 SYN 报文会携带一个 bit 的数据。因此，客户端会对第二次握手 ACK（服务端也会对第一次握手 ACK，也同理）。
体现这个原则的地方还有：

- 在第三次握手中，SN = ISN + **1**，这里的 **1** 就是第一次握手时 SYN 占用的 bit
- 在四次挥手的第二次，服务端发送 ACK，这个 ACK 不带数据，也就不需再被客户端 ACK，也不要超时重传

### 如果没有第三次握手就建立连接，会怎么样？

- 从交换 ISN 的角度，服务端无法确定客户端有没有成功接收到自己的 ISN，可靠传输无法保证。
- 考虑这种场景：客户端发出第一次握手的报文（称为 A），这段报文在网络节点中滞留时间过长。
  服务端会因为没有收到报文而不作反应；客户端会在超时重传机制下重发 SYN 报文。
  一段时间后，滞留的报文终于送达服务端（假设服务端处于`LINTEN`状态）。如果服务端发送 ACK/SYN 后，不等第三次握手就直接进入`ESTABLISH`状态，将导致不必要的错误和资源浪费，毕竟此时客户端没有建立连接的意图，不会进行数据传输。

## 成功建立连接后客户端故障怎么办？

每次服务端收到客户端的数据后都会复位一个保活计时器，时长默认是 2 小时。直到计时器超时，都没有收到客户端的数据，服务端将会发送探测报文给客户端（默认发 10 次，间隔 75s）。如果探测报文也没有被回应，服务端得知客户端故障，主动关闭连接。

## 四次挥手

通过发送`FIN`报文，A 端可以向 B 端发出断开连接的请求。

1. A 端发送 FIN，其中 SN = `x`。从`ESTABLISHED`状态转为`FIN-WAIT-1`状态
2. B 端接收到报文，回复 ACK，其中 ACK number = `x + 1`。从`ESTABLISHED`状态转为`CLOSE-WAIT`状态

A 端接收到 ACK，会将状态从`FIN-WAIT-1`转为`FIN-WAIT-2`。
由于是 A 端主动发起的请求，A 端本身肯定是没有数据需要再发送到 B 端了。但 B 端可能是在传输数据的途中接收的 FIN。
因此 B 端在回复 ACK 之后，还得等自身数据发送完毕，再发送 `FIN` 给 A 端，意为告诉 A 端可以断开连接了。

3. B 端发送 FIN，其中 SN = `y`，从`CLOSE-WAIT`状态转为`LAST-ACK`状态
4. A 端收到报文，回复 ACK，其中 ACK number = `y + 1`，由于刚才的 FIN 消耗一个 SN，这次 SN = `x + 1`

这样就可以关闭连接了吗？注意，第四次挥手是个*不带数据的 ACK 报文*。
我们遇到了和第三次握手一样的问题，这个 ACK 报文如果发送失败怎么办？

对于 B 端来说，一定要等到自己的 FIN 报文被 ACK，才能正常断开连接，没收到，就要超时重传；收到了，则转为`CLOSED`状态。
对于 A 端来说，自己这次 ACK 是不会再被 ACK 的。此时状态为`FIN-WAIT-2`。如果直接转为`CLOSED`会出什么问题吗？

TODO

因此，A 端转为`TIME-WAIT`状态，等待一定时长都没有收到 B 端重传的 FIN，则可以转为`CLOSED`状态。
而对 B 端来说，收到 ACK 就可以直接断开连接了，状态从`LAST-ACK`转为`CLOESD`
**可以看到，服务器（B 端）结束 TCP 连接的时间要比客户端（A 端）早一些。**

### 为什么 A 端的等待时长为 2MSL？

## Q & A

### 三次握手中，为什么除了第一个握手报文 SYN 除外，其它所有报文必须将 ACK = 1

RST 是什么

## 参考资料

[TCP 握手的核心是 ISN](https://www.zhihu.com/question/24853633/answer/115173386)
[关于三次握手和四次挥手，面试官想听到怎样的回答？](https://www.zhihu.com/question/271701044/answer/398114686)
[附带 gif 的资料](https://blog.csdn.net/qzcsu/article/details/72861891)
[维基百科](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8)
[为什么 ISN 要动态随机](https://www.zhihu.com/question/34400902/answer/191928024)
