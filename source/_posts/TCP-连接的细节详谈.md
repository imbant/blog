---
title: TCP 连接的细节详谈
date: 2020-03-24 15:55:08
tags: [TCP]
---

谈一谈 TCP 解决了什么问题，以及三次握手、四次挥手的细节，包括正确流程以及每个环节出错的情况

## 数据传输过程

在 TCP/IP 四层模型里，TCP 接收来自应用层的数据流，将其分割并封装为适当长度的 TCP 「报文」，通过 IP 层（网际层）传输数据。

TCP 是可以可靠传输数据的，也就是说，建立 TCP 连接的双方，能保证发出的信息一定被接收到。如何实现这一点呢？

首先，TCP 的报文是按顺序发送的，且 TCP 会对报文中包含的数据的**每个 Byte**做编号。假设报文的数据序号从 1 开始（实际上起始序号可变，原因见下文 ），第 ① 段报文包含 1460 Byte 字节，其中每个 Byte 的编号就是 1，2，3，...，1460。
发送给接收端，接收端收到报文后，用一段不携带数据的 TCP 报文（相当于只有报文头）确认，同时用确认号 1461（1460 + 1）来表示，自己受到了前 1460 Byte 的数据。
接着，发送端发送第 ② 段报文，数据长度也为 1460 Byte，这样数据编号就变成 1461，1462，1463，...，2920.
接收端收到报文后，确认的报文确认号就为 2921（2920 + 1）。
如此往复...显然，接收端无需每次都回复，比如他收到 ①~⑤ 条报文段，由于报文段按顺序发送的缘故，只需要确认第 ⑤ 段即可。
如果一共发送了五段报文，第 ③ 段接收端还没有收到，就收到了 ④、⑤ 段，说明第 ③ 段传输失败了。因此接收端只能确认收到第 ② 段。
发送端需要重发第 ③ 段，成功接收后，接收端就可以直接确认 ⑤ 段，因为 ④ ⑤ 已经收到。
![](/blog/images/TCP-连接的细节详谈1.gif)

由于 TCP 标识了报文数据的顺序，从而接收端接受数据时可以重建顺序。关于上文说到的，报文接收端为了确保可靠性，在接收到一定量的连续字节流后才发送确认。这是一种 TCP 的扩展，被称为选择确认（Selective Acknowledgement）。选择确认使得接收端可以对乱序到达的数据块进行确认。乱序到达可能是因为包的乱序交付，或者丢包。

### 可见，序号是保证可靠性的核心

然而上面的流程中，用 1 作为起始序号有安全隐患：第三方如果猜到序号，可以伪造一个 RST 报文（见下文），恶意使某一方重建连接。
因此，序号需要动态随机生成，实际上它是由操作系统随机生成的 32 位长的序号。那么自然的，TCP 通信双方就需要在建立连接时，创建好初始序号，并同步给对方。

现在概念比较多了，我们用一些缩写来代指专有名词，并看看 TCP 报文的数据包接口是否符合需求：
`SN`(sequence number)：序号，序列号，指 TCP 报文携带的数据中每个 Byte 的编号
`ISN`（Initial Sequence Number）：初始的 SN，SN 的起点，在三次握手中同步
`ACK`（Acknowledge）：确认，指接收端收到报文段后根据 SN 回复的行为
`SYN`（synchronization  `/ˌsɪŋkrənaɪˈzeɪʃən/`）：同步，指一端告诉另一端自己的 ISN
`FIN`（finish）：指断开连接

![](/blog/images/TCP-连接的细节详谈2.jpg)

可见：

- **每个**报文段都带有序列号码，也就是 SN，用于标识报文的序号。注意，虽然说 SN 标识的是报文数据中*连续*的 Byte（1000，1001，1002...），但连个连续报文段的 SN 是*不连续*的，前一段可能是 1000，下一段可能就是 1500，也就是说前一段有 500 Byte 的数据。
- **每个**报文段还会带上 ACK number。除了第一次握手的 SYN 报文，其他报文都需要有 ACK。
- 报文头中有 9 个标志符，每个占 1 Byte。
  - 上述的 ACK、SYN、FIN 三种操作都是通过对应的标识符置 1 来实现的。
  - `RST` = reset，当该位置 1 时，说明有严重差错，需要重新创建 TCP 连接。还可以用于拒绝非法的报文段和拒绝连接请求。
  - 另外 5 种不太懂...

## 三次握手

下文表述中的发送端和接收端变成了客户端和服务端，更形象一些。实际上客户端不一定是发送端，比如建立连接后服务端也可以向客户端发送 TCP 报文

1. 建立 TCP 连接，首先要做的是客户端和服务端让对方知道自己的 ISN。这就涉及到两个过程：a.客户端向服务端同步，b.服务端向客户端同步。
2. 理论上两端同时初始化它们之间的连接是可能的，不过大多数情况下都是有先后顺序的：服务端先打开一个 socket 来监听另一端的链接。服务端被被动打开后，客户端就能创建主动打开。
3. 因此，客户端生成 ISN，放在报文头的 SN 中。先向服务端发送自己的 ISN（不妨记为 `x`），同时在报文头中把 SYN 位给置 1，向服务端表明这段报文是连接请求。
4. 服务端正确收到报文，在本地保存客户端的 ISN。同时为了保证可靠传输，要向客户端发送 ACK 报文，其 ACK number 为 `x + 1`，以表明自己收到了客户端的 ISN，且值为 x
5. 这样过程 a 就完工了，还有过程 b。
6. 服务端向客户端发送自己的 ISN（不妨记为 `y`），同时在报文头中把 SYN 位 置 1，向客户端表明这段报文是连接接受请求。
7. 客户端正确收到报文，在本地保存服务端的 ISN。同样是保证可靠传输的原因，向服务端发送 ACK 报文，其 ACK number 为 `y + 1`。**注意**这是客户端发送的第二个报文，这段报文的 SN 被设为 ISN + 1，也就是 `x + 1`。

每次发送报文的过程就成为一次「握手」。可见，服务端向客户端*连续*发送了两次报文，这是没有必要的，降低了传输效率。
上述过程称为「四次握手」，将服务端连续两次的握手合并，就得到了三次握手：

> 1. 客户端发送 SYN 报文，SN = ISN
> 2. 服务端收到客户端的 SYN 后，向客户端发送 SYN/ACK 报文，带上 ACK number，SN = ISN
> 3. 客户端收到服务端的 SYN/ACK 后，向服务端发送 ACK 报文，带上 ACK number, SN = (ISN + 1)

### 容错机制

三次握手如何确保双方稳定获取了彼此的 ISN 呢？考虑每次握手的发送端：

- 第一次握手如果失败：服务端是被动打开的，还在静静等待客户端的消息。
- 第二次握手如果失败：客户端没收到自己 ISN 的 ACK，两种可能：
  - 服务端收到 SYN 了，但 ACK 报文发送失败了：信息似乎同步成功了，只是客户端不知情。
  - 服务端根本没收到 SYN：很严重，可靠性受到威胁。
    客户端没法判断究竟是哪种情况，必须处理最坏的情况，也就是服务端没收到 ISN。没收到咋办呢？周期性超时重传 SYN。
- **第三次握手如果失败**：服务端没收到自己的 ISN 的 ACK，还是两种可能：
  - 客户端收到 SYN，ACK 报文发送失败
  - 客户端没收到 SYN
    服务端必须周期性超时重传 SYN/ACK 报文

换句话说，如何感知前两次握手成功？服务端收到第三次握手，得知第二次握手成功；客户端收到第二次握手，得知第一次握手成功。第三次握手就特殊了：

> 第三次握手成功与否，或者说服务端是否接收到这次 ACK 报文，客户端是**无感知**的。

客户端发送完 ACK 报文后，就转为 `established` 状态，单方面认为三次握手成功，要发数据了。此时：

- 服务端会周期性超时重传 SYN/ACK，直到正确收到客户端的 ACK，或者超过最大时限
- 如果客户端有数据发送：除了第一次握手的 SYN 报文，其他报文都需要有 ACK。因此服务端会正常收到数据 + 正确的 ACK，相当于还是成功接收到 ACK 了，第三次握手成功，服务端也转为 `established` 状态。

可见，第三次握手的 ACK 是“不可靠的”。
这次发送 ACK 的一方没能保证自己的信息稳定传输。不过由于 ACK number 存在于第一次 SYN 之外的全部报文中，规避了不稳定的隐患。

### 那么需要对第三次握手的 ACK 再做 ACK 吗？

不需要。否则会进入互相 ACK 的死循环：
服务端收到 ACK，如果为了让客户端知道自己收到了 ACK，再次 ACK，客户端又收到 ACK，如果要保证 ACK 稳定，需要再次 ACK，服务端又 ACK...就没个头了。
所有 ACK 的发送方都不保证 ACK 的可靠性，由对方保证超时重传

**TCP 对有数据的 TCP segment 必须确认；不会为没有数据的 ACK 超时重传。**
第三次握手的 ACK 报文就没有携带数据。发送出去之后不要求接收方返回 ACK。
此时有个问题，第二次握手的 SYN/ACK 也没数据啊？按照这个规定，客户端收到 AYN/ACK 报文也不应该 ACK。
于是 TCP 设计者将 SYN 这个同步标志位 SYN 设计成占用一个字节的编号（FIN 标志位也是），也就是说 SYN 报文会携带一个 Byte 的数据。因此，客户端会对第二次握手 ACK（服务端也会对第一次握手 ACK，不过本来也要再传一次 SYN 的）。
体现这个原则的地方还有：

- 在第三次握手中，SN = ISN + **1**，这里的 **1** 就是第一次握手时 SYN 占用的 Byte，
- 在四次挥手的第二次，服务端发送 ACK，这个 ACK 不带数据，也就不需要超时重传

## 四次挥手

RST 是什么
