<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="imbant 前端工程师技术博客"><meta name="keywords" content="前端,imbant,技术博客,浏览器,Electron,React,Vue,Node,Webpack,Vite,Chrome"><title>LSP 与 VS Code 插件开发（二）语义构建 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZM9NGRYKWS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-ZM9NGRYKWS');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LSP 与 VS Code 插件开发（二）语义构建</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LSP 与 VS Code 插件开发（二）语义构建</h1><div class="post-meta">2024-12-31</div><div class="post-content"><p>这是《LSP 与 VS Code 插件开发》系列文章的第二篇。<br>第一篇：<a href="/blog/2024/08/24/LSP1/">语言服务器架构</a><br>第二篇：<a href="/blog/2024/12/31/LSP2/">语义构建</a><br>第三篇：<a href="/blog/2025/01/17/LSP3/">语言服务器协议</a></p>
<p><a href="/blog/2024/08/24/LSP1/">上一章</a>我们讲到，语言服务器的输入是源码，而输出是结构化的数据。代码编辑器（客户端）某个位置显示什么颜色，鼠标悬浮到某个位置提示什么信息，都由客户端向语言服务器请求，获取数据后，渲染到用户界面。</p>
<p>因此语言服务器需要编译源码，构建语义模型，为客户端提供<em>智能编程服务</em>。</p>
<p>所谓的 <code>编译</code> 是怎么回事？它和编译器是什么关系？本章会和大学里的编译原理知识有些关系，但保证比课本上的更有趣、更好玩！</p>
<h2 id="语言服务器与编译器的关系"><a href="#语言服务器与编译器的关系" class="headerlink" title="语言服务器与编译器的关系"></a>语言服务器与编译器的关系</h2><p>先回顾一下编译原理的基本流程：<br><code>词法分析</code> -&gt; <code>语法分析</code> -&gt; <code>语义分析</code> -&gt; <code>中间代码生成</code> -&gt; <code>代码优化</code> -&gt; <code>目标代码生成</code> -&gt; <code>...</code></p>
<h3 id="前端相似"><a href="#前端相似" class="headerlink" title="前端相似"></a>前端相似</h3><p>具体各流程的作用就不赘述了，大学课本里那些长篇大论介绍 LL(1) 文法过于乏味。<br>我们基本可以把编译器的工作分为<code>前端</code>、（<code>中端</code>）、<code>后端</code>几个流程，事实上，编译器和语言服务器在编译的过程中，<code>前端</code>的过程是非常相似的。也就是 <code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code> 几个阶段。</p>
<p>通过这三个阶段，从源码中获取语义信息后，语言服务器等待客户端请求，为编程体验服务，而编译器则是继续中端、后端，为生成目标产物服务。在这之后，两种做的事情就大相径庭了。</p>
<p>换句话说，对于 <code>console.log</code> 这一行代码，两者都经历了这样的阶段：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>进度</th>
</tr>
</thead>
<tbody><tr>
<td>源码</td>
<td>console.log</td>
</tr>
<tr>
<td>词法分析</td>
<td><code>IDENTIFIER</code> <code>DOT</code> <code>IDENTIFIER</code></td>
</tr>
<tr>
<td>语法分析</td>
<td>规约为 <code>DomainDotAccess</code>，是通过点号访问域的语法</td>
</tr>
<tr>
<td>语义分析</td>
<td><code>console</code> 符号是一个接口，<code>log</code> 符号是其中一个方法</td>
</tr>
</tbody></table>
<p>这里的 <code>DomainDotAccess</code> 是个示意，实际上可能是 <code>MemberExpression</code> 或者 <code>PropertyAccessExpression</code> 之类的，只是一个命名问题。</p>
<p>接下来，有了语义信息后，语言服务器就可以：</p>
<ol>
<li>前 7 个字母涂成红色；后三个字母涂成蓝色 <code>console.log</code> -&gt; <font color="red">console</font>.<font color="blue">log</font></li>
<li>鼠标悬停到后三个字母的位置，提示 <code>Prints to stdout with newline.</code></li>
<li>校验实际参数的数量、类型是否与函数签名相符、返回值类型是否正确</li>
<li>…</li>
</ol>
<p>而这些都是和编译器完全无关的事情。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/consolelog.png"></p>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>此外，两者的容错处理也是不一样的。当源码中出现了错误：<br>编译器会停止编译，通过标准输出等方式抛出<code>编译错误</code>，自然也没有目标产物的输出了，当然，一行代码的改动可能引起数个文件的错误，如果只遇到一个错误就停止编译，也不利于 debug，往往会尝试尽可能多的抛出错误；<br>而用户会持续不断的编码，你可以想一下，输入编写一行代码时，可能只有输入了最后一个分号 <code>;</code> 后，编译才会通过，而这期间语言服务器则会持续工作，进程不会停止，而是收集 <a target="_blank" rel="noopener" href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnostic"><code>Diagnostic</code></a>，也就是诊断信息，客户端根据这些信息，在代码编辑器上显示<font color="red">红色</font>或者<font color="orange">橙色</font>的波浪线。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/errorinlsandterminal.png"></p>
<p>通常来说，编译器能顺利编译通过的工程，语言服务器也不应出现诊断。反过来，代码编辑器中没有波浪线，理论上编译也是能过的。<br>碰到代码编辑器中标红，但能编译通过的情况倒是还好，如果代码编辑器没问题，但编译时报错，那就痛苦了。这种一般都是由于编译器和语言服务器没有统一编译标准导致的，可能是两者编译配置不同，同样一段代码，语言服务器认为是 warning，但编译器认为是 error，甚至是两者的语言版本不同（比如 python2 和 python3）。<br>另外，像 VS Code 这样的编辑器都支持插件，可能除了语言官方的语言服务器，还有别的（例如 lint 工具）在同时工作，这也会导致代码编辑器里看到的诊断比编译输出的多。从这个角度上，编译器和语言服务器的一致性也是工程化的一个重要问题。</p>
<p>这里可以看到，语言服务器的工作和运行时是无关的。换句话说，使用记事本写的 Hello World，没有语言服务器参与，经过编译器编译后，同样可以执行，而语言服务器提供的只是更好的编码体验，也就是 DX（developer experience）。</p>
<p>总的来说，编译器面向运行时一次性执行，要求最终正确性和可执行性，而语言服务器在用户编码时持续服务，要求及时性和友好性。</p>
<h3 id="使用同一种语言构建"><a href="#使用同一种语言构建" class="headerlink" title="使用同一种语言构建"></a>使用同一种语言构建</h3><p>上一章提到，语言服务器与编译器往往是同一种编程语言构建的程序。现在你应该更理解了，在编译原理前端，两者的逻辑高度相似，往后才开始异化。使用同一种语言，甚至在同一个工程中，能最大的复用代码，减少维护成本。这也是促成语言服务器架构的原因之一。<br>事实上很多语言或是编译器内置语言服务器，例如 <a target="_blank" rel="noopener" href="https://docs.deno.com/runtime/reference/lsp_integration/">Deno</a>、<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29">TypeScript</a> ，或是在内置工具链中就有语言服务器，例如 Go 和 Gopls、Rust 和 RLS。</p>
<p>当然，语言服务器的实现也并不仅是官方一种，VS Code 就<a target="_blank" rel="noopener" href="https://code.visualstudio.com/api/language-extensions/language-server-extension-guide#error-tolerant-parser-for-language-server">受不了</a> PHP 解析器不能容错，直接新写了一个语言服务器</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/vscode-php.png"></p>
<h2 id="深入理解语法与语义"><a href="#深入理解语法与语义" class="headerlink" title="深入理解语法与语义"></a>深入理解语法与语义</h2><p>刚才提到了语法分析和语义分析，这里再举几个例子详细说明下。</p>
<h3 id="十六进制颜色字面量"><a href="#十六进制颜色字面量" class="headerlink" title="十六进制颜色字面量"></a>十六进制颜色字面量</h3><p>假设我们要设计一门新的编程语言，支持十六进制的颜色字面量值。方案如下：<br>语法：定义为井号 <code>#</code> 后跟多个十六进制字符（<code>0-9</code>, <code>a-f</code>, <code>A-F</code>）。<br>语义：仅长度为 3 (<font color="red">r</font><font color="green">g</font><font color="blue">b</font>)、4（<font color="red">r</font><font color="green">g</font><font color="blue">b</font><font color="gray">a</font>）、6（<font color="red">rr</font><font color="green">gg</font><font color="blue">bb</font>）或者 8（<font color="red">rr</font><font color="green">gg</font><font color="blue">bb</font><font color="gray">aa</font>）的十六进制序列视为合法颜色值。</p>
<p>从语法上没有约束十六进制字符数量。好处在于语法规则宽松，便于解析和扩展，并且容错友好。<br>一套语法描述可能复用于编译器、语言服务器、lint 工具等多个软件，而由于软件功能不同，语义实现则各不相同。因此语法设计应该更宽松和易扩展。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">合法，白色</span><br><span class="line"><span class="selector-id">#fff</span></span><br><span class="line"></span><br><span class="line">语法错误，z不是十六进制字符，</span><br><span class="line"><span class="selector-id">#zzz</span></span><br><span class="line"></span><br><span class="line">语义错误，长度不对</span><br><span class="line"><span class="selector-id">#ff</span></span><br><span class="line"><span class="selector-id">#fffff</span></span><br><span class="line"><span class="selector-id">#ffffffffffffffffff</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推导和显式类型声明"><a href="#类型推导和显式类型声明" class="headerlink" title="类型推导和显式类型声明"></a>类型推导和显式类型声明</h3><p>再举一个变量定义的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a</code> 的值是 <code>5</code>，类型是<code>整数</code>。这里没有显式的声明 <code>a</code> 的类型，因此是通过等号右边的表达式的类型推导出来的。<br>右值是一个字面量，词法分析时可以通过正则匹配之类的方法得知它是一个 token，比如叫 <code>INT_DIGIT</code>。接着语法分析时，得知 <code>INT_DIGIT</code> 就是一个普通的字面量表达式。然后语义分析时，就知道一个整数字面量表达式的类型是<code>整数</code>，这是编程语言运行时就定义好的，无需额外的语法声明的（<code>typeof 5 == &quot;int&quot;</code>）。<br>与之对应的，如果给 a 加了显式的类型声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>那么语法上就是通过等号左边的 <code>int</code> token，在语义上查找符号表得知是<code>整数</code>类型。接着和右值类型比较，发现是一致的，这样就通过了类型检查。</p>
<p>不论是类型推导或者显示声明类型，<code>a</code> 的类型都是基于词法分析后根据语法结构决定的。前者是分析了字面量值 <code>5</code> 的语义，为<code>整数</code>；后者是分析了类型符号 <code>int</code> 的语义，同样是<code>整数</code>。这两个过程都是基于语法分析，判断语义。</p>
<h3 id="语法错误更为严重"><a href="#语法错误更为严重" class="headerlink" title="语法错误更为严重"></a>语法错误更为严重</h3><p>语法错误的影响更严重，例如少了半个括号，会影响后续也许是整个文件的代码的作用域。相比来说，语义错误更可控，能尽量避免蝴蝶效应。</p>
<p>例如这样的 Go 代码，<code>bar</code> 是一个键为 <code>int</code>，值为 <code>string</code> 的字典。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/gostringint.png"></p>
<p>现在有两个典型的语义错误，分别在第 11 行，尝试用整数字面量赋值给 <code>string</code> 类型；和 13 行，尝试将 <code>string</code> 值赋值给 <code>int</code> 类型。</p>
<p>现在我们制造一个语法错误，删掉第 9 行的一个右括号 <code>]</code>，这显然是一个简单的编码失误，但语言服务器不干了，没有正确的语法支持，很难继续构建语义，第 11 行、第 13 行的红色波浪线也消失了。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/gointstring2.png"></p>
<p>一个简单的语法错误，导致了整个文件的语义分析失败，这是语法错误的严重性。而且报出的错误信息也只能基于语法，和代码改动毫无关系，这简直是新手的噩梦。</p>
<blockquote>
<p>顺便提一句，其实有经验的开发者一眼就能看出问题所在，但而基于编译原理的解析程序则难以做到这一点。我认为这也许会是大语言模型的一个应用场景，结合代码编辑器，帮助代码初学者快速定位语法错误。</p>
</blockquote>
<h3 id="语法错误更快出现"><a href="#语法错误更快出现" class="headerlink" title="语法错误更快出现"></a>语法错误更快出现</h3><p>语义错误通常比语法错误更晚出现，因为语法错误出现在语法分析阶段，而语义错误在之后的语义分析阶段。</p>
<p>通常编译单个文件，已经能得到完整的语法错误信息，而语义错误可能需要等整个工程的编译才能完全收集到。</p>
<p>例如，有些编程语言里支持“严格模式”，用来增强类型检查、避免隐式错误等。它在语法上可能就是一行字符串字面量或者魔法注释，例如 <code>&quot;use strict&quot;</code> 或者 <code>// @ts-check</code>。它们自身没有语法错误，但是加上这行代码会影响后续成千上万行代码的语义分析，带来数个语义错误。</p>
<p>这里有一个提高语言服务器性能的方法：<br>将语言服务器拆分成两个，一个面向语法，一个面向语义。<br>语法服务器很轻量，只负责词法分析、语法分析，有语法错误时立即反馈诊断。另外也可以提供一些完全基于语法的，和语义无关的小功能，例如<a target="_blank" rel="noopener" href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.18/specification/#textDocument_documentColor">显示颜色</a>。<br>语义服务器更重，负责全部的语义构建和服务。<br>将语法诊断和其他小功能从语义服务器中剥离，可以降低语义服务器的开销，也能让轻量的功能更快的反馈给用户。<br>当然，这不是说语义服务器就不做词法、语法分析了，依然会做，甚至尝试容错，但会更专注在和语义相关的功能上。</p>
<p>Vue 的<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=Vue.volar">语言服务器</a>就是这么做的。</p>
<h2 id="语义模型"><a href="#语义模型" class="headerlink" title="语义模型"></a>语义模型</h2><p>这里展示一下我做的基于 Node 的语言服务器，编译这段代码后得到的语义模型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">                LogInfo(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">        while <span class="literal">true</span> &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/lastmodel.png"></p>
<p>这是一门自研的 DSL 语言，其具体的语义就不做讨论了，但可以看到，在 Node 内存中，我的语义模型是一个大的对象，<code>graph</code>、<code>func</code>、<code>for</code>、<code>if</code>、<code>while</code> 关键字分别开辟了新的作用域，它们层层嵌套，形成一颗树结构。<br>既然是树结构，深度优先遍历算法就是可行的。第 4 行的 <code>if</code> 语句，要从根节点开始经过 <code>root</code> -&gt; <code>func A</code> -&gt; <code>for</code> -&gt; <code>if</code> 几个语法节点，才能访问的到。<br>鼠标移动到第 5 行的 <code>LogInfo</code> 上，就要经过上述的深度优先搜索，根据鼠标位置的行列号，一层一层查找语义模型，得知此位置的语义是一个函数名，悬浮提示出函数签名，按 F12 还能跳转到函数声明的地方。<br>这个在树结构上层层查找的过程，有点类似语法分析中由上至下的递归下降分析法，从非终结符开始，递归展开，直到终结符；或者反过来，从终结符开始，递归折叠，直到非终结符。但两者还是有本质区别的，语法分析是为了构建语法树，而语义分析是基于语法树，构建语义模型。只不过从实现上，这个语义模型也是一个树结构的，毕竟是基于语法，两者的结构也是相似的。</p>
<h3 id="shadow-机制"><a href="#shadow-机制" class="headerlink" title="shadow 机制"></a>shadow 机制</h3><p>有了这个形象的树形结构，我们就可以从新的角度理解编程语言中的 <code>shadow</code> 机制。<br><code>shadow</code> 机制通常指在当前作用域和外层作用域中，同名变量的优先级问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">0</span></span><br><span class="line">    while (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            foo += <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 8 行的 <code>foo</code> 变量最终的值会是 12，也就是改变了第 6 行的 <code>foo</code>，即使外层还有两个同名变量。<br>在语义分析阶段，第 8 行是一个加法赋值语句，右值是 10，左值是一个符号 x。为了找到这个符号的语义，语言服务器会从语义模型中当前光标位置的就近作用域开始寻找，也就是 <code>if</code> 开辟的作用域中，发现符号表中有一个 <code>foo</code>，它的语义是 <code>int</code> 类型的变量。这样，第 8 行的 <code>foo</code> 符号就是一个变量的语义了，也许会变成 variable 的蓝色；而它的定义位置，根据符号表，得知在第 6 行，按 F12 跳转到定义，光标就会跳转到第 6 行。<br>另外，得知第 8 行 <code>foo</code> 的语义后，还会做一系列的语义检查，常见的编程语言可能会检查：</p>
<ol>
<li><code>foo</code> 是可写的局部变量，可以作为左值</li>
<li><code>foo</code> 是个整数，可以做加法赋值</li>
<li>右值是个整数字面量，和左值的类型相同，可以赋值</li>
<li>…</li>
</ol>
<p><code>shadow</code> 机制对于代码补全也有积极意义：在 if 代码块中，输入 <code>fo</code>，语言服务器应该仅列出一个 <code>foo</code> 变量，忽略外层的两个。让我们给最外层的 <code>foo</code> 改名叫 <code>foo001</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func A() &#123;</span><br><span class="line"><span class="deletion">--  var foo = 0</span></span><br><span class="line"><span class="addition">++  var foo001 = 0</span></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        var foo = 1</span><br><span class="line">        if true &#123;</span><br><span class="line">            var foo = 2</span><br><span class="line"></span><br><span class="line">            foo += 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候就会补全 if 中的 <code>foo</code> 和外层的 <code>foo001</code>，而不会再出现 while 中的 <code>foo</code>。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/lsp-vscode/fooshadowcompletion.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，我们明白了语言服务器想要提供智能编程服务，首先需要编译，构建语义模型，这个过程和编译器前端很相似。有了语义模型基础，语言服务器要做的就是接收客户端请求，返回数据。两者通信的过程中，使用的协议就是 LSP（语言服务器协议）。它定义了哪些智能编程能力，通信的具体内容是什么？我们下一章继续。</p>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><p>我在播客 <a target="_blank" rel="noopener" href="https://www.xiaoyuzhoufm.com/episode/66a1197533ddcbb53cd7a063"><code>Web Worker</code></a> 上和几位 Vue 生态的大佬、团队成员们聊过 Vue 插件，欢迎收听。</p>
<p>我也会在<a target="_blank" rel="noopener" href="https://okjk.co/OUqto1">即刻</a>分享语言服务器相关的开发心得，计划将它们整理成系列文章，欢迎关注。</p>
</div><div class="tags"><a href="/blog/tags/LSP/"><i class="fa fa-tag"></i>LSP</a><a href="/blog/tags/VS-Code/"><i class="fa fa-tag"></i>VS Code</a><a href="/blog/tags/%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%8F%E8%AE%AE/"><i class="fa fa-tag"></i>语言服务器协议</a></div><div class="post-nav"><a class="pre" href="/blog/2025/01/17/LSP3/">LSP 与 VS Code 插件开发（三）语言服务器协议</a><a class="next" href="/blog/2024/11/12/%E5%9C%A8-VS-Code-%E4%B8%AD%E8%B0%83%E8%AF%95%E5%92%8C%E8%BF%90%E8%A1%8C-Go-%E7%A8%8B%E5%BA%8F/">在 VS Code 中调试和运行 Go 程序</a></div><div class="giscus"></div><script src="https://giscus.app/client.js" data-repo="imbant/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkyNDkzOTc0NDM=" data-category="General" data-category-id="DIC_kwDODt2Aw84Ch79K" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>