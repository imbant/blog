<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><title>BrowserRouter vs HashRouter | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">BrowserRouter vs HashRouter</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">BrowserRouter vs HashRouter</h1><div class="post-meta">2020-02-25</div><div class="post-content"><p>使用 React-Router 的应用一定是单页应用（SPA）。与多页应用相比，SAP 可以在前端自定义和控制路由。但后端也有一套路由处理的能力，此时前后端在控制路由层面如何权衡呢？</p>
<h2 id="BrowserRouter-："><a href="#BrowserRouter-：" class="headerlink" title="BrowserRouter ："></a>BrowserRouter ：</h2><p>普通的 url 路径，网络请求中会把 url 完整地发送给服务器，相应的，服务器要对前端定义的每个 pathname(window.location.pathname 这个东西) 都做相应的处理。<br>例如一个页面有 根、user 和 about 三个路径：<br><a href="https://example.com/" target="_blank" rel="noopener">https://example.com/</a><br><a href="https://example.com/user" target="_blank" rel="noopener">https://example.com/user</a><br><a href="https://example.com/about" target="_blank" rel="noopener">https://example.com/about</a><br>后端需要分别写三个不同 GET 请求的方法（express 为例）：<br><code>app.get(&#39;/&#39;)</code>、<code>app.get(&#39;/user&#39;)</code> 和 <code>app.get(&#39;/about&#39;)</code><br>目前有两个问题：</p>
<ol>
<li>如果后端不作处理，会怎么样？<br>举个例子，如果后端只定义了 <code>app.get(&#39;/&#39;)</code>，那访问根域名是正常的。此时前端做页面跳转 <code>history.push(&#39;/user&#39;)</code>，这样是能正常看到 <code>/user</code> 下对应的组件的。但如果刷新页面，或者重新访问 <a href="https://example.com/user" target="_blank" rel="noopener">https://example.com/user</a> ，页面会白屏，原因是服务器没有定义 <code>/user</code> 下要返回什么 HTML，因此前端没有拿到 HTML。</li>
<li>难道前端每新定义一个路由，后端都需要去手动适配吗？<br>不需要，后端可以设定任何路由都返回访问根路由时同样的 HTML，让前端 Router 自己去解析 url，判断如何渲染组件。<br>有一个 create-react-app 上的例子，所有请求都返回 index.html：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendFile(path.join(__dirname, <span class="string">"build"</span>, <span class="string">"index.html"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="HashRouter："><a href="#HashRouter：" class="headerlink" title="HashRouter："></a>HashRouter：</h2><p>url 看起来像这样：<br><a href="https://example.com/#/user" target="_blank" rel="noopener">https://example.com/#/user</a><br><a href="https://example.com/#/about" target="_blank" rel="noopener">https://example.com/#/about</a><br># 后的部分称为 hash，这一部分是不会发送到后端的，因此后端也无需对每个特定的 path 都做处理。<br>根据 React Router 文档的说明，# 后边有三种不同格式：</p>
<ul>
<li>“slash” - Creates hashes like #/ and #/sunshine/lollipops</li>
<li>“noslash” - Creates hashes like # and #sunshine/lollipops</li>
<li>“hashbang” - Creates “ajax crawlable” (deprecated by Google) hashes like #!/ and #!/sunshine/lollipops</li>
</ul>
<p>看起来简单些。不过 React Router 文档中有一条：HashRouter 不支持 <code>location.key</code> 和 <code>location.state</code>；另外，BrowserRouter 也支持 HTML5 history API（其中包括了 pushState、replaceState 方法和 popstate 事件），因此更鼓励使用 BrowserRouter。<br>两者的差别很简单：发送请求时服务端是否能接收到 path。相应的涉及到后端是否要针对单独的路由进行配置。</p>
<h2 id="回到最初的问题："><a href="#回到最初的问题：" class="headerlink" title="回到最初的问题："></a>回到最初的问题：</h2><p>一个 SPA 的路由控制方面，前后端如何权衡？显然，前端控制路由是 SPA 的特点，也因此才有了切换路由无需刷新页面的优势（相比于多页应用）。在 BrowserRouter 模式下，后端应用需要做额外配置，来适配不同 url 的请求。</p>
<h2 id="一个-React-Router-Redux-应用在浏览器刷新、返回操作时的行为分析"><a href="#一个-React-Router-Redux-应用在浏览器刷新、返回操作时的行为分析" class="headerlink" title="一个 React Router + Redux 应用在浏览器刷新、返回操作时的行为分析"></a>一个 React Router + Redux 应用在浏览器刷新、返回操作时的行为分析</h2><ul>
<li>返回操作：<br>redux 中的 state 不变<br>全局 layout 中的变量不变<br>待证实：用 react-router 管理路由的 SPA 中浏览器做返回操作，具体行为由 router 自己接管（比如 prevent default？）；返回操作不影响的内存（比如全局 layout、redux 中的 global modal），也不变。（如果是 a 页面内的 a.1 返回到 a.2，page modal 是不是也不变呢）</li>
<li>刷新操作：<br>上述变量被释放，应用重新启动，从 layout 开始初始化，一步一步到路由对应的组件</li>
</ul>
</div><div class="tags"><a href="/blog/tags/React-Router/"><i class="fa fa-tag"></i>React Router</a></div><div class="post-nav"><a class="pre" href="/blog/2020/03/09/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">React 生命周期</a><a class="next" href="/blog/2019/12/20/CSS-%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3-iOS-%E5%BE%AE%E4%BF%A1%E6%A9%A1%E7%9A%AE%E7%AD%8B%E6%95%88%E6%9E%9C%E4%B8%8E-position-fixed-%E8%81%94%E5%8A%A8%E7%9A%84%E5%9D%91/">CSS 方式解决 iOS 微信橡皮筋效果与 position: fixed 联动的坑</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/Node/" style="font-size: 15px;">Node</a> <a href="/blog/tags/React-Router/" style="font-size: 15px;">React Router</a> <a href="/blog/tags/%E7%A7%BB%E5%8A%A8-Web-%E5%BC%80%E5%8F%91/" style="font-size: 15px;">移动 Web 开发</a> <a href="/blog/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 15px;">微信</a> <a href="/blog/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/blog/tags/JS/" style="font-size: 15px;">JS</a> <a href="/blog/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/blog/tags/React/" style="font-size: 15px;">React</a> <a href="/blog/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/blog/tags/linux/" style="font-size: 15px;">linux</a> <a href="/blog/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E9%A2%91/" style="font-size: 15px;">移动端视频</a> <a href="/blog/tags/Devops/" style="font-size: 15px;">Devops</a> <a href="/blog/tags/TCP/" style="font-size: 15px;">TCP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/05/08/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E6%A0%87%E5%87%86/">命令行选项标准</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/20/JS-%E5%8E%9F%E5%9E%8B%E9%93%BE/">JS 原型链、this 与 class</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/13/JS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS 事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/10/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">Promise 必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/07/web-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/">web 移动端开发踩坑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/24/TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%86%E8%8A%82%E8%AF%A6%E8%B0%88/">TCP 连接的细节详谈</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/13/React-Diffing-%E7%AE%97%E6%B3%95/">React Diffing 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/09/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">React 生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/25/BrowserRouter-vs-HashRouter/">BrowserRouter vs HashRouter</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/20/CSS-%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3-iOS-%E5%BE%AE%E4%BF%A1%E6%A9%A1%E7%9A%AE%E7%AD%8B%E6%95%88%E6%9E%9C%E4%B8%8E-position-fixed-%E8%81%94%E5%8A%A8%E7%9A%84%E5%9D%91/">CSS 方式解决 iOS 微信橡皮筋效果与 position: fixed 联动的坑</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>