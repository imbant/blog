<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><title>JS 原型链、this 与 class | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS 原型链、this 与 class</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS 原型链、this 与 class</h1><div class="post-meta">2020-04-20<span> | </span><span class="category"><a href="/blog/categories/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/">面试基础</a></span></div><div class="post-content"><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>实现属性、方法共享</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>为（构造）函数的 prototype 属性增加字段。<br>用 new 关键字 + 构造函数，实现创建一个对象。这个语句就会返回一个“含有”构造函数 prototype 里属性和方法的新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"doggy"</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 非严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> Dog(<span class="string">"las"</span>);</span><br></pre></td></tr></table></figure>

<p>这样<code>Alaska</code>这个对象就可以调用<code>getName</code>方法了，它由<code>Dog</code>函数共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alaska.getName(); <span class="comment">// las</span></span><br><span class="line">Alaska.type = <span class="string">"doggy"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="new-操作中究竟发生了什么？"><a href="#new-操作中究竟发生了什么？" class="headerlink" title="new 操作中究竟发生了什么？"></a>new 操作中究竟发生了什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> Dog(<span class="string">"las"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 新建对象</span></span><br><span class="line">Alaska.__proto__ = Dog.prototype; <span class="comment">// 原型引用</span></span><br><span class="line">Dog.call(Alaska); <span class="comment">// 调用构造函数，绑定 this</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h2><p>执行<code>Alaska.getName()</code>会首先在<code>Alaska</code>本身查找<code>getName</code>属性，找不到，则寻找原型。<br>想要获得其原型，可以通过<code>Object.getPrototypeOf</code>方法，或者更常见但已经被<strong>弃用</strong>的直接访问<code>__proto__</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Alaska);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Alaska.__proto__;</span><br></pre></td></tr></table></figure>

<p>它们指向同一个对象，也就是<code>Dog.prototype</code>。其中包含了<code>getName</code>属性，调用它。</p>
<p>这就是「链」的概念。自身找不到的属性/方法，就去原型上找；原型上找不到，就再在原型的原型上找。<br>原型本身就是对象，原型链的顶端指向<code>Object.prototype</code>，其中有<code>hasOwnProperty</code>、<code>toString</code>等方法。而<code>Object.prototype</code>的原型指向 null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ul>
<li><p>用语法结构创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// o 继承了 Object.prototype 里的所有属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">"N"</span>, <span class="string">"M"</span>, <span class="string">"$"</span>, <span class="string">"L"</span>];</span><br><span class="line"><span class="comment">// a 继承于 Array.prototype（indexOf，map）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数也是一种对象，f 继承于 Function.prototype（call、bind）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="regexp">/^[a-z|A-Z]&amp;/</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用构造函数创建</p>
<p>用<code>new</code>操作符作用的函数被称为构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="comment">// g.__proto__ === Graph.prototype，g 的原型指向 Graph 的 prototype 属性</span></span><br><span class="line"><span class="comment">// g.__proto__.__proto__ === Object.prototype</span></span><br><span class="line"><span class="comment">// Graph.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">// Graph.__proto__.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure>

<p>其中，构造函数不带括号<code>new Foo</code>和<code>new Foo()</code>的写法一样，相当于没有指定参数的情况下调用。</p>
</li>
<li><p>用 Object.create 创建</p>
<p>ES5 引入的方法，返回值是一个对象，原型为第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">c</span>: <span class="number">1</span>, <span class="attr">d</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.__proto__ === a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="built_in">Object</span>.create(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.__proto__ === b</span></span><br></pre></td></tr></table></figure>

<p><em>几乎</em>所有的 JS 对象都是原型链顶端<code>Object</code>的实例（共享它的属性和方法）,但也有例外：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// c.__proto__ === null</span></span><br><span class="line"></span><br><span class="line">n.hasOwnProperty();</span><br><span class="line"><span class="comment">// error: n.hasOwnProperty is not a function</span></span><br><span class="line"><span class="comment">// n 原型链上没有 hasOwnProperty，而 Object.prototype 中有。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 class 关键字创建</p>
<p>ES6 新特性，见后文。</p>
</li>
</ul>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>构造函数将想共享的属性和方法写入原型对象，其生成的实例就可以调用他们。<br>构造函数定义 prototype，而实例则访问<code>__proto__</code>或者<code>Object.getPrototypeOf</code>，查找原型链上的属性和方法。</p>
<p>在原型链中查找属性对性能有副作用；有两个方法<strong>不会</strong>遍历原型链：<code>Object.prototype.hasOwnProperty()</code>和<code>Object.map</code></p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><code>this</code>是一个大坑，在各个语境下的值都可能不同，在浏览器环境或者 Node 运行时中也不一样，因此会分情况讨论。<br>总的来说<code>this</code>大都出现在函数内部，</p>
<blockquote>
<p>通常，在普通函数中指向被<em>调用</em>时的对象，在箭头函数中取决于被<em>定义</em>时的上下文</p>
</blockquote>
<h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><p>this 指向全局对象<code>globalThis</code>，在浏览器环境中它就是<code>window</code>，它实现了 setTimeout 等函数。</p>
<h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><p>函数内部的 this 值取决于函数被调用的方式。</p>
<h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><p>构造函数通常是不写返回值的。这样在函数内 this 定义的属性/方法，就会被绑定到新构造出的对象上，this 自身指向这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>构造函数如果有了返回值，那对 this 设置的属性/方法都没意义了。</p>
<h3 id="对象内方法中的-this"><a href="#对象内方法中的-this" class="headerlink" title="对象内方法中的 this"></a>对象内方法中的 this</h3><p>形如<code>a.b()</code>，this 指向这个方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里用箭头函数 this 就为全局对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.c;</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="非箭头函数的简单调用"><a href="#非箭头函数的简单调用" class="headerlink" title="非箭头函数的简单调用"></a>非箭头函数的简单调用</h3><p><strong>严格模式</strong>下保持进入执行环境（execution context）时的值，如果执行环境未定义，则为 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>非严格模式</strong>下指向调用函数的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "use strict";</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// 浏览器中为 window</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过 call、apply 来传递不同环境下的 this 值。常用于调用对象内部方法之外的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// this 的值取决于函数的调用方式（非严格模式）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">logA.call(x);</span><br><span class="line">logA.call(y);</span><br></pre></td></tr></table></figure>

<p>call、apply 的区别在于第一个参数后边的写法，是传一个参数数组，还是一个一个把参数写明。</p>
</li>
<li><p>也可以用 bind 创建一个 this 被<em>永久</em>绑定的函数。<br>这一点在 React 的 class component 里非常常见</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded1 = logA.bind(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</span><br><span class="line">binded1(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded2 = logA.bind(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;);</span><br><span class="line">binded2(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded3 = binded2.bind(&#123; <span class="attr">a</span>: <span class="number">4</span> &#125;);</span><br><span class="line">binded3(); <span class="comment">// 3 ，bind 只会生效一次，this 已经被永久绑定到 &#123; a: 3 &#125; 了</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="箭头函数和其中的-this"><a href="#箭头函数和其中的-this" class="headerlink" title="箭头函数和其中的 this"></a>箭头函数和其中的 this</h3><p>箭头函数<em>不会</em>创建 this，而是从作用域链上层继承 this。箭头函数和普通的声明<code>function</code>的函数区别之一是，箭头函数的 this 在其被<strong>定义</strong>时就确定了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  b: <span class="number">10</span>,</span><br><span class="line">  logB: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.b, <span class="keyword">this</span> === that),</span><br><span class="line">  logB2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.logB(); <span class="comment">// undefined, true</span></span><br><span class="line">a.logB2(); <span class="comment">// 10, a 自己</span></span><br></pre></td></tr></table></figure>

<p><code>logB</code>是一个箭头函数，由于对象<em>字面量</em>内部不会开辟新的作用域，所以<code>logB</code>所在作用域就是全局作用域，箭头函数里的 this 指向全局对象。<br><code>logB2</code>是一个普通函数，在调用时才会决定 this 值，所以执行<code>a.logB2()</code>时，<code>logB2()</code>里的 this 指向 a</p>
<p>可见，在对象<em>字面量</em>里用箭头函数定义方法，可能会有预期之外的错误。如果是在构造函数里用箭头函数定义方法，则不会有这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.logName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F(<span class="string">"lbw"</span>);</span><br><span class="line">f.logName(); <span class="comment">// lbw</span></span><br></pre></td></tr></table></figure>

<p>构造函数还是函数，会开辟自己的作用域，在里边 this 指向被新构造的对象，因此用箭头函数内的 this 也会指向这个新对象。</p>
<h4 id="箭头函数不可以作为构造函数"><a href="#箭头函数不可以作为构造函数" class="headerlink" title="箭头函数不可以作为构造函数"></a>箭头函数不可以作为构造函数</h4><p>和<code>new</code>一起用会报错</p>
<h4 id="箭头函数没有-prototype-属性"><a href="#箭头函数没有-prototype-属性" class="headerlink" title="箭头函数没有 prototype 属性"></a>箭头函数没有 prototype 属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">F.prototype.a = <span class="number">1</span>; <span class="comment">// TypeError: Cannot set property 'a' of undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> F(); <span class="comment">// TypeError: F is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM-事件处理函数、HTML-内联事件处理函数"><a href="#DOM-事件处理函数、HTML-内联事件处理函数" class="headerlink" title="DOM 事件处理函数、HTML 内联事件处理函数"></a>DOM 事件处理函数、HTML 内联事件处理函数</h3><p>非箭头函数下 this 都指向 DOM 元素本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">root.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.currentTarget === <span class="keyword">this</span>); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"console.log(this)"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- this 为 DOM 元素本身 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数下为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">root.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.currentTarget === <span class="keyword">this</span>); <span class="comment">// false，this === window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = obj.bar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn2()());</span><br></pre></td></tr></table></figure>

<p>用字面量创建一个对象，其中 bar 方法是用 function 关键字定义的普通函数，所以 bar 内部的 this 会在其被调用时决定。</p>
<p>fn 是 obj.bar() 的返回值，也就是说调用 bar 的是 obj，this 指向 obj<br>而 bar() 本身返回一个箭头函数，箭头函数内的 this 是继承自外部作用域的，所以指向 bar 内部的 this，根据前边的分析，指向 obj</p>
<p>fn2 则是单纯的做了一个引用赋值操作，将 fn2 指向一个函数对象所在的内存。上边的写法和直接定义 fn2 为函数没区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以 fn2()() 指向全局对象。</p>
<h2 id="额外阅读"><a href="#额外阅读" class="headerlink" title="额外阅读"></a>额外阅读</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/4</a></p>
</div><div class="tags"><a href="/blog/tags/JS/"><i class="fa fa-tag"></i>JS</a></div><div class="post-nav"><a class="next" href="/blog/2020/04/13/JS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS 事件循环</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/Node/" style="font-size: 15px;">Node</a> <a href="/blog/tags/React-Router/" style="font-size: 15px;">React Router</a> <a href="/blog/tags/%E7%A7%BB%E5%8A%A8-Web-%E5%BC%80%E5%8F%91/" style="font-size: 15px;">移动 Web 开发</a> <a href="/blog/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 15px;">微信</a> <a href="/blog/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/blog/tags/JS/" style="font-size: 15px;">JS</a> <a href="/blog/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/blog/tags/React/" style="font-size: 15px;">React</a> <a href="/blog/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/blog/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E9%A2%91/" style="font-size: 15px;">移动端视频</a> <a href="/blog/tags/Devops/" style="font-size: 15px;">Devops</a> <a href="/blog/tags/TCP/" style="font-size: 15px;">TCP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/20/JS-%E5%8E%9F%E5%9E%8B%E9%93%BE/">JS 原型链、this 与 class</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/13/JS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS 事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/10/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">Promise 必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/04/07/web-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/">web 移动端开发踩坑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/24/TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%86%E8%8A%82%E8%AF%A6%E8%B0%88/">TCP 连接的细节详谈</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/13/React-Diffing-%E7%AE%97%E6%B3%95/">React Diffing 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/09/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">React 生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/25/BrowserRouter-vs-HashRouter/">BrowserRouter vs HashRouter</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/20/CSS-%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3-iOS-%E5%BE%AE%E4%BF%A1%E6%A9%A1%E7%9A%AE%E7%AD%8B%E6%95%88%E6%9E%9C%E4%B8%8E-position-fixed-%E8%81%94%E5%8A%A8%E7%9A%84%E5%9D%91/">CSS 方式解决 iOS 微信橡皮筋效果与 position: fixed 联动的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/12/11/%E5%AE%89%E5%8D%93%E5%BE%AE%E4%BF%A1-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE-%E7%9B%B8%E5%85%B3%E8%B8%A9%E5%9D%91/">安卓微信 视频播放 相关踩坑</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>