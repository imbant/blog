<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>JS 原型链、this 与 class | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS 原型链、this 与 class</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS 原型链、this 与 class</h1><div class="post-meta">2020-04-20</div><div class="post-content"><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>实现属性、方法共享</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>为（构造）函数的 prototype 属性增加字段。<br>用 new 关键字 + 构造函数，实现创建一个对象。这个语句就会返回一个“含有”构造函数 prototype 里属性和方法的新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&quot;doggy&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 非严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> Dog(<span class="string">&quot;las&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样<code>Alaska</code>这个对象就可以调用<code>getName</code>方法了，它由<code>Dog</code>函数共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alaska.getName(); <span class="comment">// las</span></span><br><span class="line">Alaska.type = <span class="string">&quot;doggy&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="new-操作中究竟发生了什么？"><a href="#new-操作中究竟发生了什么？" class="headerlink" title="new 操作中究竟发生了什么？"></a>new 操作中究竟发生了什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> Dog(<span class="string">&quot;las&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">const</span> Alaska = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 新建对象</span></span><br><span class="line">Alaska.__proto__ = Dog.prototype; <span class="comment">// 原型引用</span></span><br><span class="line">Dog.call(Alaska); <span class="comment">// 调用构造函数，绑定 this</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h2><p>执行<code>Alaska.getName()</code>会首先在<code>Alaska</code>本身查找<code>getName</code>属性，找不到，则寻找原型。<br>想要获得其原型，可以通过<code>Object.getPrototypeOf</code>方法，或者更常见但已经被<strong>弃用</strong>的直接访问<code>__proto__</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Alaska);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Alaska.__proto__;</span><br></pre></td></tr></table></figure>

<p>它们指向同一个对象，也就是<code>Dog.prototype</code>。其中包含了<code>getName</code>属性，调用它。</p>
<p>这就是「链」的概念。自身找不到的属性/方法，就去原型上找；原型上找不到，就再在原型的原型上找。<br>原型本身就是对象，原型链的顶端指向<code>Object.prototype</code>，其中有<code>hasOwnProperty</code>、<code>toString</code>等方法。而<code>Object.prototype</code>的原型指向 null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alaska.__proto__; <span class="comment">// &#123;getName: ƒ, constructor: ƒ&#125;</span></span><br><span class="line">Alaska.__proto__ === Dog.prototype; <span class="comment">// true</span></span><br><span class="line">Alaska.__proto__.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// Alaska.__proto__ 原型是对象，对象的原型指向 Object.prototype</span></span><br><span class="line">Alaska.__proto__.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ul>
<li><p>用语法结构创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// o 继承了 Object.prototype 里的所有属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;N&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;L&quot;</span>];</span><br><span class="line"><span class="comment">// a 继承于 Array.prototype，比如 indexOf、map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数也是一种对象，f 继承于 Function.prototype（call、bind）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="regexp">/^[a-z|A-Z]&amp;/</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>用构造函数创建</p>
<p>用<code>new</code>操作符作用的函数被称为构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="comment">// g.__proto__ === Graph.prototype，g 的原型指向 Graph 的 prototype 属性</span></span><br><span class="line"><span class="comment">// g.__proto__.__proto__ === Object.prototype</span></span><br><span class="line"><span class="comment">// Graph.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">// Graph.__proto__.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure>

<p>其中，构造函数不带括号<code>new Foo</code>和<code>new Foo()</code>的写法一样，相当于没有指定参数的情况下调用。</p>
</li>
<li><p>用 Object.create 创建</p>
<p>ES5 引入的方法，返回值是一个对象，原型为第一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">c</span>: <span class="number">1</span>, <span class="attr">d</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.__proto__ === a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="built_in">Object</span>.create(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.__proto__ === b</span></span><br></pre></td></tr></table></figure>

<p><em>几乎</em>所有的 JS 对象都是原型链顶端<code>Object</code>的实例（共享它的属性和方法）,但也有例外：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// c.__proto__ === null</span></span><br><span class="line"></span><br><span class="line">n.hasOwnProperty();</span><br><span class="line"><span class="comment">// error: n.hasOwnProperty is not a function</span></span><br><span class="line"><span class="comment">// n 原型链上没有 hasOwnProperty，而 Object.prototype 中有。</span></span><br></pre></td></tr></table></figure></li>
<li><p>用 class 关键字创建</p>
<p>ES6 新特性，见后文。</p>
</li>
</ul>
<h3 id="Function-与-Object-的关系"><a href="#Function-与-Object-的关系" class="headerlink" title="Function 与 Object 的关系"></a>Function 与 Object 的关系</h3><p>由于 <code>Object</code> 可以被 <code>new</code> 作用，所以是构造「函数」</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>Function</code> 是一个「对象」，也是一个「函数」。作为对象，有自己的原型对象 <code>__proto__</code>，作为函数，它也会通过原型链从 Function.prototype 继承一些属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Function</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>构造函数将想共享的属性和方法写入原型对象，其生成的实例就可以调用他们。<br>构造函数定义 prototype，而实例则访问<code>__proto__</code>或者<code>Object.getPrototypeOf</code>，查找原型链上的属性和方法。</p>
<p>在原型链中查找属性对性能有副作用；有两个方法<strong>不会</strong>遍历原型链：<code>Object.prototype.hasOwnProperty()</code>和<code>Object.map</code></p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><code>this</code>是一个大坑，在各个语境下的值都可能不同，在浏览器环境或者 Node 运行时中也不一样，因此会分情况讨论。<br>总的来说<code>this</code>大都出现在函数内部，</p>
<blockquote>
<p>通常，在普通函数中指向被<em>调用</em>时的对象，在箭头函数中取决于被<em>定义</em>时的上下文</p>
</blockquote>
<h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><p>this 指向全局对象<code>globalThis</code>，在浏览器环境中它就是<code>window</code>，它实现了 setTimeout 等函数。</p>
<h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><p>函数内部的 this 值取决于函数被调用的方式。</p>
<h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><p>构造函数通常是不写返回值的。这样在函数内 this 定义的属性/方法，就会被绑定到新构造出的对象上，this 自身指向这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>构造函数如果有了返回值，那对 this 设置的属性/方法都没意义了。</p>
<h3 id="对象内方法中的-this"><a href="#对象内方法中的-this" class="headerlink" title="对象内方法中的 this"></a>对象内方法中的 this</h3><p>形如<code>a.b()</code>，this 指向这个方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里用箭头函数 this 就为全局对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.c;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="非箭头函数的简单调用"><a href="#非箭头函数的简单调用" class="headerlink" title="非箭头函数的简单调用"></a>非箭头函数的简单调用</h3><p><strong>严格模式</strong>下保持进入执行环境（execution context）时的值，如果执行环境未定义，则为 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>非严格模式</strong>下指向调用函数的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;use strict&quot;;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// 浏览器中为 window</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过 call、apply 来传递不同环境下的 this 值。常用于调用对象内部方法之外的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">// this 的值取决于函数的调用方式（非严格模式）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">logA.call(x);</span><br><span class="line">logA.call(y);</span><br></pre></td></tr></table></figure>

<p>call、apply 的区别在于第一个参数后边的写法，是传一个参数数组，还是一个一个把参数写明。</p>
</li>
<li><p>也可以用 bind 创建一个 this 被<em>永久</em>绑定的函数。<br>这一点在 React 的 class component 里非常常见</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded1 = logA.bind(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</span><br><span class="line">binded1(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded2 = logA.bind(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;);</span><br><span class="line">binded2(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> binded3 = binded2.bind(&#123; <span class="attr">a</span>: <span class="number">4</span> &#125;);</span><br><span class="line">binded3(); <span class="comment">// 3 ，bind 只会生效一次，this 已经被永久绑定到 &#123; a: 3 &#125; 了</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="箭头函数和其中的-this"><a href="#箭头函数和其中的-this" class="headerlink" title="箭头函数和其中的 this"></a>箭头函数和其中的 this</h3><p>箭头函数<em>不会</em>创建 this，而是从作用域链上层继承 this。箭头函数和普通的声明<code>function</code>的函数区别之一是，箭头函数的 this 在其被<strong>定义</strong>时就确定了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">logB</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.b, <span class="built_in">this</span> === that),</span><br><span class="line">  <span class="attr">logB2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.b, <span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.logB(); <span class="comment">// undefined, true</span></span><br><span class="line">a.logB2(); <span class="comment">// 10, a 自己</span></span><br></pre></td></tr></table></figure>

<p><code>logB</code>是一个箭头函数，由于对象<em>字面量</em>内部不会开辟新的作用域，所以<code>logB</code>所在作用域就是全局作用域，箭头函数里的 this 指向全局对象。<br><code>logB2</code>是一个普通函数，在调用时才会决定 this 值，所以执行<code>a.logB2()</code>时，<code>logB2()</code>里的 this 指向 a</p>
<p>可见，在对象<em>字面量</em>里用箭头函数定义方法，可能会有预期之外的错误。如果是在构造函数里用箭头函数定义方法，则不会有这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.logName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F(<span class="string">&quot;lbw&quot;</span>);</span><br><span class="line">f.logName(); <span class="comment">// lbw</span></span><br></pre></td></tr></table></figure>

<p>构造函数还是函数，会开辟自己的作用域，在里边 this 指向被新构造的对象，因此用箭头函数内的 this 也会指向这个新对象。</p>
<h4 id="箭头函数不可以作为构造函数"><a href="#箭头函数不可以作为构造函数" class="headerlink" title="箭头函数不可以作为构造函数"></a>箭头函数不可以作为构造函数</h4><p>和<code>new</code>一起用会报错</p>
<h4 id="箭头函数没有-prototype-属性"><a href="#箭头函数没有-prototype-属性" class="headerlink" title="箭头函数没有 prototype 属性"></a>箭头函数没有 prototype 属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">F.prototype.a = <span class="number">1</span>; <span class="comment">// TypeError: Cannot set property &#x27;a&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> F(); <span class="comment">// TypeError: F is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM-事件处理函数、HTML-内联事件处理函数"><a href="#DOM-事件处理函数、HTML-内联事件处理函数" class="headerlink" title="DOM 事件处理函数、HTML 内联事件处理函数"></a>DOM 事件处理函数、HTML 内联事件处理函数</h3><p>非箭头函数下 this 都指向 DOM 元素本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">root.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.currentTarget === <span class="built_in">this</span>); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- this 为 DOM 元素本身 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数下为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">root.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.currentTarget === <span class="built_in">this</span>); <span class="comment">// false，this === window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2 = obj.bar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn2()());</span><br></pre></td></tr></table></figure>

<p>用字面量创建一个对象，其中 bar 方法是用 function 关键字定义的普通函数，所以 bar 内部的 this 会在其被调用时决定。</p>
<p>fn 是 obj.bar() 的返回值，也就是说调用 bar 的是 obj，this 指向 obj<br>而 bar() 本身返回一个箭头函数，箭头函数内的 this 是继承自外部作用域的，所以指向 bar 内部的 this，根据前边的分析，指向 obj</p>
<p>fn2 则是单纯的做了一个引用赋值操作，将 fn2 指向一个函数对象所在的内存。上边的写法和直接定义 fn2 为函数没区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，执行 fn2()() 已经不是对象内调用方法了（与 obj 无关），是全局环境的直接调用，所以 fn2()() 指向全局对象。</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>类是特殊的函数。类的声明<code>class A &#123;&#125;</code>或表达式<code>const A = class &#123;&#125;</code>不会变量提升。类内部的代码都是在严格模式下运行的</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>类的构造函数，在 <code>new</code> 关键字创建实例时执行。如果没有显式指定构造函数，则会添加一个默认构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性、方法和-static"><a href="#属性、方法和-static" class="headerlink" title="属性、方法和 static"></a>属性、方法和 static</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>可以在类内部直接声明属性或方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A()</span><br><span class="line">a.x <span class="comment">// 1</span></span><br><span class="line">a.y <span class="comment">// 2</span></span><br><span class="line">a.foo() <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不过这种在类内部声明属性的方式，在当前（2022年4月）浏览器支持有限，需要 Babel 等构建一下</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>可以用 <code>static</code> 声明静态方法和属性。<br>静态方法不能在类<strong>实例</strong>上调用静态方法，只能用<strong>类名</strong>调用<br>静态属性同理，不能在类<strong>实例</strong>中访问，只能用<strong>类名</strong>访问<br>静态属性/方法是与实例无关的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A()</span><br><span class="line">a.x <span class="comment">// undefined</span></span><br><span class="line">A.x <span class="comment">// 1</span></span><br><span class="line">a.foo <span class="comment">// undefined</span></span><br><span class="line">A.foo() <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态属性似乎是比较新的特性，暂时没查到具体的兼容性，在新版的 Chrome 和 Safari 上已经可用了</p>
</blockquote>
<h3 id="子类的静态方法"><a href="#子类的静态方法" class="headerlink" title="子类的静态方法"></a>子类的静态方法</h3><p>子类可以在自己的静态方法里调用父类的静态方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 注意，如果 bar 不是静态方法，会报错</span></span><br><span class="line">    <span class="built_in">super</span>.foo()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.bar() <span class="comment">// &#x27;foo&#x27; &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>用于扩展子类。子类的原型会是父类的 <code>prototype</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;render in screen&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getRootName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;view&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="keyword">new</span> Button(<span class="string">&#x27;submit&#x27;</span>)</span><br><span class="line">button <span class="keyword">instanceof</span> Button <span class="comment">// true</span></span><br><span class="line">button <span class="keyword">instanceof</span> View <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/13/JS%20class3.png" alt="示意图"></p>
<p><code>Button extends View</code> 创建了两个原型引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Button.__proto__ === View <span class="comment">// 子类的原型等于父类（而不是父类的 prototype）</span></span><br><span class="line">Button.prototype.__proto__ === View.prototype <span class="comment">// 子类实例的原型的原型等于父类的 prototype</span></span><br></pre></td></tr></table></figure>

<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super 用于在子类访问父类的方法</p>
<h3 id="构造函数中"><a href="#构造函数中" class="headerlink" title="构造函数中"></a>构造函数中</h3><p>在子类的构造函数里 <code>super()</code> 可以调用父类的构造函数。<br>注意一定要在访问 <code>this</code> <strong>之前</strong>调用 <code>super</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复写方法"><a href="#复写方法" class="headerlink" title="复写方法"></a>复写方法</h3><p>在子类的普通方法中，<code>super[key]</code> <code>super.key</code> 可以调用父类上的方法。</p>
<p>即使不使用 <code>super</code>，子类通过 <code>this</code> 也同样可以访问到父类的方法（和属性）。<br>区别在于，<code>super.good</code> 直接调用父类的函数实现，而 <code>this.good</code> 会在函数作用域链上寻找 <code>good</code> 最近的实现，两者的函数实现可能不同。<br>因此 <code>super</code> 常用在复写父类的<strong>同名</strong>方法上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">good</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is A&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">good</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里想要调用父类的 good，不能直接写 this.good</span></span><br><span class="line">    <span class="comment">// 因为作用域链里最近的 good 就是函数本身，会造成递归</span></span><br><span class="line">    <span class="comment">// 注意，这里的 super 无需在访问 this 之前调用</span></span><br><span class="line">    <span class="built_in">super</span>.good()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is B&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>constructor</code> 本身也是一个复写的例子，想要调用父类的构造函数，不能直接 <code>this.constructor</code>，而是借助 <code>super</code></p>
<h2 id="class与普通函数的区别"><a href="#class与普通函数的区别" class="headerlink" title="class与普通函数的区别"></a>class与普通函数的区别</h2><h3 id="class-必须使用-new-操作符"><a href="#class-必须使用-new-操作符" class="headerlink" title="class 必须使用 new 操作符"></a>class 必须使用 new 操作符</h3><p>class 创建对象时需要用 <code>new</code>，而普通函数可以直接调用，浏览器环境内会以 <code>window</code> 作为 <code>this</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">A() <span class="comment">// window.x === 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line">B() <span class="comment">// 语法错误</span></span><br></pre></td></tr></table></figure>

<h3 id="class-声明不会提升"><a href="#class-声明不会提升" class="headerlink" title="class 声明不会提升"></a>class 声明不会提升</h3><p>function 的声明是会提升的，所以可以先调用函数，再声明函数。class 则不会提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A() <span class="comment">// window.x === 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125; <span class="comment">// 语法错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="class-不能用-call、apply-改变-this"><a href="#class-不能用-call、apply-改变-this" class="headerlink" title="class 不能用 call、apply 改变 this"></a>class 不能用 call、apply 改变 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line">B.call(a) <span class="comment">// error: Class constructor B cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="keyword">new</span> B.call(a) <span class="comment">// error: B.call is not a constructor</span></span><br><span class="line"></span><br><span class="line">B.bind(a) <span class="comment">// <span class="doctag">TODO:</span> 这句不会报错，能顺利执行...</span></span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://javascript.info/static-properties-methods">static properties methods</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">mdn</a><br><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></p>
</div><div class="tags"><a href="/blog/tags/JS/"><i class="fa fa-tag"></i>JS</a></div><div class="post-nav"><a class="pre" href="/blog/2020/05/08/%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E6%A0%87%E5%87%86/">命令行选项标准</a><a class="next" href="/blog/2020/04/13/JS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS 事件循环</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script></div></body></html>