<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>ChatGPT 的流式对话是怎么实现的 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ChatGPT 的流式对话是怎么实现的</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ChatGPT 的流式对话是怎么实现的</h1><div class="post-meta">2023-03-20</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>网页里 ChatGPT 是逐字输出文字的，很像人类在一个一个打字：<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/sse-chatgpt/sse2.gif"></p>
<p>API 文档里这种方式称为“流式” <code>stream</code>，实现方法是 <code>server-sent events</code>(SSE)。本质上它是 HTTP 请求，可以实现服务端向客户端一段一段地推送消息。</p>
<p>与 <code>WebSocket</code> 不同的是，<code>SEE</code> 依然用 HTTP 协议，而客户端不能向服务端发消息，数据流是<strong>单向</strong>的，更加轻量。</p>
<h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>让 ChatGPT 分别实现服务端和客户端的 <code>SSE</code> 实例：</p>
<p>服务端用 node:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置允许跨域请求</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  res.setHeader(</span><br><span class="line">    <span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span></span><br><span class="line">  );</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/events&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置响应头</span></span><br><span class="line">  res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line">  res.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">  res.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> maxCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; maxCount) &#123;</span><br><span class="line">      <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString();</span><br><span class="line">      res.write(<span class="string">`data: <span class="subst">$&#123;date&#125;</span>\n\n`</span>);</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当客户端断开连接时，停止发送数据</span></span><br><span class="line">  req.on(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Listening on port 3000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> EventSource(<span class="string">&quot;http://localhost:3000/events&quot;</span>);</span><br><span class="line"></span><br><span class="line">source.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可见 <code>SSE</code> 请求有这些特征：</p>
<ul>
<li>数据是纯文本（<code>text/event-stream</code>），具体是 utf-8 编码的文本，比起二进制效率要低</li>
<li>使用长连接（<code>keep-alive</code>），复用一个 TCP 连接</li>
<li>数据不被缓存（<code>no-cache</code>），保证拿到数据的实时性</li>
</ul>
<p>devtool 中以 <code>EventStream</code> 的形式显示数据</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/sse-chatgpt/EventStream.png"></p>
<p>值得一提的是，在 ChatGPT 网站里开 devtool，SSE 请求是看不到 <code>EventStream</code> 的，似乎是<a target="_blank" rel="noopener" href="https://github.com/Azure/fetch-event-source/issues/3">本地调试</a>才能看到数据。</p>
<h2 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h2><p>服务端每次发送 <code>SSE</code> _消息_，由一个或者多个 <code>message</code> 组成，每个 <code>message</code> 都能传递 <code>Id</code>、<code>Type</code>、<code>Data</code> 这三项数据，一条 <code>message</code> 的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[field]: value\n</span><br></pre></td></tr></table></figure>

<p>其中 field 可以是 <code>id</code>、<code>event</code> 、 <code>data</code>，对应 devtool 中的三个表头，还可以是 <code>retry</code>。可见一条 <code>message</code> 以 <code>\n</code> 结尾</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p><code>data</code> 代表数据内容，每条数据以 <code>\n</code> 结尾。前边说一次消息可能对应一个或者多个 <code>message</code>，比如传递一行数据，就是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: message\n\n</span><br></pre></td></tr></table></figure>

<p>这里是<strong>两个</strong> <code>\n</code>，其实是和前边说 <code>message</code> 也以 <code>\n</code> 结尾，是相通的，传递多行数据时就能看出区别了：比如传一个 json</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;\n</span><br><span class="line">data: &quot;a&quot;: 2,\n</span><br><span class="line">data: &quot;b&quot;: true\n</span><br><span class="line">data: &#125;\n\n</span><br></pre></td></tr></table></figure>

<p>这一次信息里有四条 message，其中前边都是<em>一个</em> <code>\n</code>，最后是<em>两个</em> <code>\n</code> 结尾。可以理解为多出来的 <code>\n</code> 代表这次消息结束了。</p>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/sse-chatgpt/EventStream-data.png"></p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p><code>type</code> 定义事件类型，在客户端 <code>EventSource</code> 除了监听默认的 <code>message</code> 事件，还可以监听自定义类型的事件，是一种分发消息的机制。</p>
<p>服务器在前边的例子后再发一段自定义事件 <code>someEvent</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event: someEvent\n           # 和前一个例子一样，一个 \n 代表消息没结束，message 结束了</span><br><span class="line">data: custom event\n\n       # 两个 \n 代表一次消息结束</span><br></pre></td></tr></table></figure>

<p>客户端监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;message:&quot;</span> + event.data);</span><br><span class="line">&#125;);</span><br><span class="line">source.addEventListener(<span class="string">&quot;someEvent&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;someEvent&quot;</span> + event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/sse-chatgpt/EventStream-type.png"></p>
<p>在客户端，<code>EventSource</code> 只能监听一个类型的消息，需要自己选择是默认的 <code>message</code>，还是自定义的事件名字，这个和 <code>DOM</code> 的 <code>addEventListener</code> 很像。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p><code>SSE</code> 自带了断线重连功能，这也是比起 <code>WebSock</code> 需要自建断线重连功能的优势。方法就是每个消息都传一个 <code>id</code>，客户端记录在 <code>eventSource.lastEventId</code> 里。重新连接时，客户端请求头 <code>header</code> 会传一个 <code>Last-Event-ID</code>，告知服务器收到了哪些消息。</p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/server-sent-events">现代 JavaScript 教程</a>中推荐服务端把 <code>id</code> 附加到 <code>data</code> 后，确保 <code>data</code> 全部收到后再更新 <code>lastEventId</code>。我理解原因是如果先收到 <code>id</code>，在接收 <code>data</code> 时断网，数据没有全部收到，但已经改变过 <code>lastEventId</code>，重连时这段 <code>data</code> 就丢了。</p>
<blockquote>
<p>我理解这段逻辑和 TCP 发送报文是异曲同工的，但是更轻量。<br><code>id</code> 应该是有规律的值，这样消息才是有序的，服务端也能用一个 <code>lastEventId</code> 就知道后续发哪些消息。</p>
</blockquote>
<blockquote>
<p>不过 <code>SSE</code> 是单项通信，不用担心被猜到滑动窗口范围内的 ISN，用 RST 报文恶意攻击，所以不需要三次握手交换 ISN。</p>
</blockquote>
<p><img src="https://imbant-blog.oss-cn-shanghai.aliyuncs.com/blog-img/sse-chatgpt/EventStream-id.png"></p>
<h2 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h2><p><code>retry</code> 可以让服务端设置每次客户端断线后，每次重连之间的延迟响应时间。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>服务端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置允许跨域请求</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  res.setHeader(</span><br><span class="line">    <span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span></span><br><span class="line">  );</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/events&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置响应头</span></span><br><span class="line">  res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line">  res.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">  res.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = [</span><br><span class="line">    <span class="string">&quot;event: otherEvent \n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data: custom message \n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id: 1\n\n&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;data: object: \n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id: 2\n\n&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;data: &#123; \n&quot;</span>,</span><br><span class="line">    <span class="string">`data: &quot;a&quot;: 2,\n`</span>,</span><br><span class="line">    <span class="string">`data: &quot;b&quot;: true\n`</span>,</span><br><span class="line">    <span class="string">&quot;data: &#125; \n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id: 3\n\n&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;event: someEvent\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data: custom event\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id: 4\n\n&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; data.length) &#123;</span><br><span class="line">      res.write(data[count]);</span><br><span class="line">      <span class="comment">// res.write(`event: bye\ndata: bye-bye\n\n`)</span></span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当客户端断开连接时，停止发送数据</span></span><br><span class="line">  req.on(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Listening on port 3000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> source = <span class="keyword">new</span> EventSource(<span class="string">&quot;http://localhost:3000/events&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  source.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;message: &quot;</span> + event.data);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  source.addEventListener(<span class="string">&quot;someEvent&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;someEvent: &quot;</span> + event.data);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 node 启动服务器，就可以在浏览器里看到 <code>SSE</code> 请求了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/server-sent-events">现代 JavaScript 教程</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events">MDN-使用服务器发送事件</a></p>
</div><div class="tags"><a href="/blog/tags/HTTP/"><i class="fa fa-tag"></i>HTTP</a></div><div class="post-nav"><a class="next" href="/blog/2023/03/16/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E7%BC%96%E8%BE%91-mdn-%E4%B8%AD%E6%96%87%E9%A1%B5%E9%9D%A2/">如何参与编辑 mdn 中文页面</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script></div></body></html>