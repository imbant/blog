<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta content="telephone=no" name="format-detection"><meta name="description" content="技术博客，记录语言服务器(LSP)开发、VS Code/Cursor 插件开发、生成式 AI 与 Agent 技术、前端开发和 golang"><meta name="keywords" content="前端,imbant,技术博客,浏览器,Electron,React,Vue,Node,Webpack,Vite,Chrome"><meta name="robots" content="index, follow"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><title>SquiggleConf 2025：ts-go 的新进展 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZM9NGRYKWS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-ZM9NGRYKWS');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SquiggleConf 2025：ts-go 的新进展</h1><div class="post-meta">2025-12-06</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6"><span class="toc-number">1.1.</span> <span class="toc-text">编译时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSP"><span class="toc-number">1.2.</span> <span class="toc-text">LSP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E7%A7%BB%E6%A4%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%94%B9%E9%80%A0"><span class="toc-number">2.</span> <span class="toc-text">Go 移植过程中的改造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">2.1.</span> <span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E5%81%9A-map-key"><span class="toc-number">2.3.</span> <span class="toc-text">复合类型做 map key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%89%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Go 语言的选型</span></a></li></ol></div></div><div class="post-content"><p>12 月，TypeScript 团队更新了 ts-go 项目的<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/">最新进展</a>。总的来说，原生版本的语言服务已经比较成熟可用了，并且完全支持标准 LSP 协议。（不过我试用原生版本的第一天就发现个 <a target="_blank" rel="noopener" href="https://github.com/microsoft/typescript-go/issues/2209">bug</a> 哈哈哈，无伤大雅）</p>
<p>编译器本体也非常完善、健壮了，不过编译器 api 依然在开发中，因此第三方工具，如 vue 语言服务器、tsloader 等还用不了原生版本。</p>
<p>最近看了 TS 团队成员 Jake Bailey 在 SquiggleConf 2025 分享的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=C_ePbVZqXrw&t=6820s">Why and How We Ported TypeScript to Go</a>，还有一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=rAMdPw_1ELQ">播客</a>，我的 takeaway 是：</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>Go 有语言级并发，这是比起 js 最大的优势之一，并行化是能达到 10 倍性能提升的关键。</p>
<p>这在编译时和语言服务上都有体现：</p>
<h3 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h3><p>ts 的编译分为 parse、bind、check、emit 四个阶段。其中 parse、bind、emit 都比较容易并行化，并且得益于持久不变的 AST 设计，移植过程中由并发引起的问题非常的少。</p>
<ul>
<li>parse 阶段，预处理、词法分析和语法分析是可以并行的，因为不涉及具体的语义，多个文件之间谁先谁后不影响 AST 的产出结果，并且这个阶段最多只会有语法错误。</li>
<li>bind 阶段，这个属于知识范围之外了，我理解主要是构建符号表的过程，依然不知道具体的类型，只会产生 undefined 之类的错误，因此也可以并行。</li>
<li>emit 阶段，生成 js 代码，只是遍历和打印，可以并行。</li>
</ul>
<p>特殊的就是 check 阶段，语义检查是一个非常复杂的过程，check 是 ts 源码中代码量非常大、在一次编译中非常耗时的部份。<br>通常遍历一次 AST 是不够的，并且文件之间依赖关系错综复杂，a.ts 的类型检查可能依赖 b.ts 的结果，b.ts 又依赖 c.ts 的结果，这意味着检查的顺序非常重要。这里，官方的说法是分组并发。</p>
<p>这里建议详细看看原文 <a target="_blank" rel="noopener" href="https://jakebailey.dev/talk-squiggleconf-2025/68">PPT</a>，能有很直观的理解。</p>
<p>不过顺序完全随机的并发还是带来了一些问题，比如类型 id 的分配顺序会不一致（漂移）。解法就是一些场景依然需要用不变的数据来做排序，比如文件系统的文件顺序。</p>
<h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>对语言服务器来说，客户端的请求是随机的——很有可能请求 <code>diagnostic</code> 的同时又需要 <code>hover</code>。js 实现必须排队处理请求，先完成 <code>diagnostic</code>，再响应 <code>hover</code>，而 Go 版本可以并发处理多个请求。用户可以在编码时更快的得到来自多个请求的反馈。</p>
<p>另外，这样的提速对 AI Coding 也有意义：agent 通常会在生成一段代码后，看下当前客户端的 lint 状态，或者说有哪些 <code>diagnostic</code>，读取这些报错信息，尝试修复，好及时纠正方向，继续生成下一段代码。<br>但 agent 是有超时限制的，没人希望他们一次干个 4 小时。语言服务器更快的响应意味着 agent 能在有限的时间内，完成更多的交互轮次，减少超时带来的阻断。</p>
<h2 id="Go-移植过程中的改造"><a href="#Go-移植过程中的改造" class="headerlink" title="Go 移植过程中的改造"></a>Go 移植过程中的改造</h2><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>JS 天然会构造大量的小对象，随手写一个 <code>&#123;&#125;</code> 就会分配内存。而同样的代码移植到到 Go 就很痛了。因此针对热点函数，例如 NewIdentifier，做了内存池复用对象。例如 checker.ts 这个文件，内存开销减少了 96%。</p>
<p>构造小对象的 ts 版本：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewIdentifier</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">Identifier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: SyntaxKind.Identifier,</span><br><span class="line">    name, <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内存池版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIdentifier</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Identifier</span></span> &#123;</span><br><span class="line">    id := identifierPool.Get().(*Identifier)</span><br><span class="line">    id.Kind = SyntaxKindIdentifier</span><br><span class="line">    id.Name = name</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>V8 针对字符串拼接做了底层优化，因此 js 可以频繁的使用 <code>+=</code> 来拼接字符串。<br>实际上会用一棵树来表示这种连续拼接的字符串，并在必须要使用字符串时，再把树拍平。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> part <span class="keyword">of</span> parts) &#123;</span><br><span class="line">  result += part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但移植到 Go 则千万不能这么做，因为 Go 的字符串是不可变的，每次拼接都会分配新的内存，性能会非常差。Go 要替换为 <code>strings.Builder</code> 高效拼接字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line"><span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">    builder.WriteString(part)</span><br><span class="line">&#125;</span><br><span class="line">result := builder.String()</span><br></pre></td></tr></table></figure>

<h3 id="复合类型做-map-key"><a href="#复合类型做-map-key" class="headerlink" title="复合类型做 map key"></a>复合类型做 map key</h3><p>js 的 map，如果是对象作为 key，实际上会根据对象指针来区分不同的 key。而 Go 则不同，结构体作为 key，那么只要结构体的字段值相同，就会被认为是同一个 key——内容一样就是一样。</p>
<p>当然，使用指针作为 key，就能模拟 js 的行为了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>移植过程中也遇到了 nil 指针的值判等、<a target="_blank" rel="noopener" href="https://jakebailey.dev/posts/go-shadowing/">变量的 shadow 问题</a>等，Go 的常见语法特性带来的问题。</p>
<h2 id="Go-语言的选型"><a href="#Go-语言的选型" class="headerlink" title="Go 语言的选型"></a>Go 语言的选型</h2><ul>
<li>ts 的源码没有特别多面向对象设计，更多的是数据、函数和接口。这和 Go 的思想不谋而合。因此移植起来相对容易。</li>
<li>ts 有 GC，因此不太容易移植到 C/C++ 这种需要手动管理内存的语言。Go 的 GC 很合适。</li>
<li>Go 容易上手，学习成本不高。</li>
<li>Go 社区反响很好，在微软官宣 Go 版本的<em>当天</em>，Go 社区就发现<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/72815">用 Go 编译 ts-go 比预期的慢</a>。随后 Go 1.25 修复了这个问题，并把 ts-go 加入 Go 编译器的 benchmark 测试中。</li>
<li>对实际代码文本，ts 源码只需要非常少的改动就能变成 go 代码。项目初期是 Jake Bailey 写了一个生成工具，把数万行 ts 的 AST 转为 Go 代码，然后简单测试就做到 5 倍编译速度的提升。ai 在初步移植过程中实际上没帮上什么大忙，Jake 说可能是用 Go 实现的编译器太少了，缺乏语料。</li>
<li>在工程里有非常庞大的 package 时，Go 的语言服务器 gopls 有性能问题，移植过程中也碰到了这个问题，解法是分包，把大 package 拆成更小的 package。但不得不说，这个问题真的非常影响体验——同样不分包的代码库，GoLand 里会明显比 gopls 更流畅。 </li>
</ul>
</div><div class="tags"><a href="/blog/tags/Go/"><i class="fa fa-tag"></i>Go</a><a href="/blog/tags/LSP/"><i class="fa fa-tag"></i>LSP</a><a href="/blog/tags/GitHub-Copilot/"><i class="fa fa-tag"></i>GitHub Copilot</a><a href="/blog/tags/TypeScript/"><i class="fa fa-tag"></i>TypeScript</a><a href="/blog/tags/MCP/"><i class="fa fa-tag"></i>MCP</a><a href="/blog/tags/tsc/"><i class="fa fa-tag"></i>tsc</a></div><div class="post-nav"><a class="next" href="/blog/2025/06/07/antlr-angle-brackets/">Antlr 文法设计中的尖括号问题</a></div><div class="giscus"></div><script src="https://giscus.app/client.js" data-repo="imbant/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkyNDkzOTc0NDM=" data-category="General" data-category-id="DIC_kwDODt2Aw84Ch79K" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>