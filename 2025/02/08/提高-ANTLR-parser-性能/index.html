<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="imbant 前端工程师技术博客"><meta name="keywords" content="前端,imbant,技术博客,浏览器,Electron,React,Vue,Node,Webpack,Vite,Chrome"><title>提高 Antlr 的编译性能 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZM9NGRYKWS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-ZM9NGRYKWS');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">提高 Antlr 的编译性能</h1><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">提高 Antlr 的编译性能</h1><div class="post-meta">2025-02-08</div><div class="post-content"><p>总结一些提高 antlr 词法和语法分析性能的方法。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果你构建的是编译器，通常要预处理、预编译、编译文件，使得同一个文件的语法信息（也就是解析树或者 AST）需要用三次。<br>对于同样的源文件，antlr 生成的解析树（parse trees）是一样的。因此可以复用第一次的语法信息，省去两次的开销。</p>
<p>首先，可以在内存中缓存它的性能，这还是很容易实现的，并且效果很好，能显著提升一次编译执行的效率。<br>其次，可以考虑如何持久化储存解析树或者 AST，使得那些每次编译时持久不变的文件（例如库、头文件）仅仅被编译一次，后续都无需编译。当然，存盘就意味着 I/O 和编码、解码开销，当心这些开销超过缓存节省的开销。缓存文件使用二进制格式（例如使用一些 proto）会比 json 快得多，将零碎的小文件聚合在一个文件也是个好选择。</p>
<h3 id="对简单、轻量的文件使用-SLL-模式"><a href="#对简单、轻量的文件使用-SLL-模式" class="headerlink" title="对简单、轻量的文件使用 SLL 模式"></a>对简单、轻量的文件使用 SLL 模式</h3><p>antlr 的预测模式有 SLL 和 LL。其中 SLL 最快，但难以容错，适合没什么二义性、轻量的文件。LL 模式则更慢，但更准确，适合复杂文件。</p>
<p>以下代码来自<a target="_blank" rel="noopener" href="https://tomassetti.me/improving-the-performance-of-an-antlr-parser/">这篇文章</a>。<br>行为是先用 SLL 模式解析，如果解析失败，再用 LL 模式解析。但要注意，如果 SLL 频繁失败，反而会降低性能。</p>
<p>在 antlr 的 vs code 插件中，也有类似的 <a target="_blank" rel="noopener" href="https://github.com/mike-lischke/vscode-antlr4/blob/d2a673818518de6cabfd26760ea593b09a8fd096/src/backend/SourceContext.ts#L783">Node.js 代码</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this code comes from The Definitive ANTLR 4 Reference by Terence Parr, main author of ANTLR</span></span><br><span class="line"><span class="comment">// try with simpler/faster SLL(*)</span></span><br><span class="line">parser.getInterpreter().setPredictionMode(PredictionMode.SLL);</span><br><span class="line"><span class="comment">// we don&#x27;t want error messages or recovery during first try</span></span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line">parser.setErrorHandler(<span class="keyword">new</span> BailErrorStrategy());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  parser.startRule();</span><br><span class="line">  <span class="comment">// if we get here, there was no syntax error and SLL(*) was enough;</span></span><br><span class="line">  <span class="comment">// there is no need to try full LL(*)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParseCancellationException ex) &#123;</span><br><span class="line">  <span class="comment">// thrown by BailErrorStrategy</span></span><br><span class="line">  tokens.reset();</span><br><span class="line">  <span class="comment">// rewind input stream</span></span><br><span class="line">  parser.reset();</span><br><span class="line">  <span class="comment">// back to standard listeners/handlers</span></span><br><span class="line">  parser.addErrorListener(ConsoleErrorListener.INSTANCE);</span><br><span class="line">  parser.setErrorHandler(<span class="keyword">new</span> DefaultErrorStrategy());</span><br><span class="line">  <span class="comment">// full now with full LL(*)</span></span><br><span class="line">  parser.getInterpreter().setPredictionMode(PredictionMode.LL);</span><br><span class="line">  parser.startRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="减少语法分支"><a href="#减少语法分支" class="headerlink" title="减少语法分支"></a>减少语法分支</h3><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">indexTypeClause:</span><br><span class="line">    USING_SYMBOL indexType</span><br><span class="line">    | TYPE_SYMBOL indexType</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">indexTypeClauseOpt:</span><br><span class="line">    (USING_SYMBOL | TYPE_SYMBOL) indexType</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>在大部分场景下，可选值 <code>?</code> 性能比分支 <code>|</code> 更好。例如，假设一门语言的 if 语句的条件可以带括号，也可以不带</p>
<!-- TODO: 例子不太好，括号应该成对出现 -->

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifStatement:</span><br><span class="line">    &#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">    | &#x27;if&#x27; expression</span><br></pre></td></tr></table></figure>

<p>就可以优化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifStatement:</span><br><span class="line">    &#x27;if&#x27; (&#x27;(&#x27;)? expression (&#x27;)&#x27;)?</span><br></pre></td></tr></table></figure>

<h3 id="语义谓词（semantic-predicates）"><a href="#语义谓词（semantic-predicates）" class="headerlink" title="语义谓词（semantic predicates）"></a>语义谓词（semantic predicates）</h3><p>语义谓词是指 .g4 文件中用 <code>&#123;&#125;</code> 花括号包括起来的部分。这些部分需要 antlr 生成目标代码后自行编写函数实现逻辑。<br>语法分析文件中（parser.g4）谓词放到最前<br>词法分析文件中（lexer.g4）谓词放到最后</p>
<h3 id="使用最新的-antlr-来生成目标代码"><a href="#使用最新的-antlr-来生成目标代码" class="headerlink" title="使用最新的 antlr 来生成目标代码"></a>使用最新的 antlr 来生成目标代码</h3><p>antlr 是个比较活跃的项目，更新还是比较频繁的。</p>
<ul>
<li>4.10：2022 年 4 月 11 日</li>
<li>4.11：2022 年 9 月 5 日</li>
<li>4.12：2023 年 2 月 20 日</li>
<li>4.13：2023 年 5 月 21 日</li>
</ul>
<p>例如以前只有 JavaScript 版本目标代码，现在 TypeScript 也有了。另外新版本通常会有性能优化。</p>
<h2 id="重要参考资料"><a href="#重要参考资料" class="headerlink" title="重要参考资料"></a>重要参考资料</h2><p><a target="_blank" rel="noopener" href="https://tomassetti.me/improving-the-performance-of-an-antlr-parser/">https://tomassetti.me/improving-the-performance-of-an-antlr-parser/</a><br><a target="_blank" rel="noopener" href="https://groups.google.com/g/antlr-discussion/c/PpgPQU5jA3Q/m/P4K6Y0BXBQAJ">https://groups.google.com/g/antlr-discussion/c/PpgPQU5jA3Q/m/P4K6Y0BXBQAJ</a><br><a target="_blank" rel="noopener" href="https://github.com/antlr/antlr4/issues/4613">https://github.com/antlr/antlr4/issues/4613</a></p>
</div><div class="tags"><a href="/blog/tags/antlr4/"><i class="fa fa-tag"></i>antlr4</a><a href="/blog/tags/antlr/"><i class="fa fa-tag"></i>antlr</a><a href="/blog/tags/compiler/"><i class="fa fa-tag"></i>compiler</a></div><div class="post-nav"><a class="next" href="/blog/2025/01/17/LSP3/">LSP 与 VS Code 插件开发（三）语言服务器协议</a></div><div class="giscus"></div><script src="https://giscus.app/client.js" data-repo="imbant/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkyNDkzOTc0NDM=" data-category="General" data-category-id="DIC_kwDODt2Aw84Ch79K" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>