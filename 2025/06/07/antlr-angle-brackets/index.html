<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="_s8zp9HC5xK3I7RCh_8RJrSUgYtyNgc09bZvTV11nFI"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta content="telephone=no" name="format-detection"><meta name="description" content="技术博客，记录语言服务器(LSP)开发、VS Code/Cursor 插件开发、生成式 AI 与 Agent 技术、前端开发和 golang"><meta name="keywords" content="前端,imbant,技术博客,浏览器,Electron,React,Vue,Node,Webpack,Vite,Chrome"><meta name="robots" content="index, follow"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><title>Antlr 文法设计中的尖括号问题 | imbAnt's blog</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZM9NGRYKWS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-ZM9NGRYKWS');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/blog/.">imbAnt's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Antlr 文法设计中的尖括号问题</h1><div class="post-meta">2025-06-07</div><div class="post-content"><p>聊一聊使用 <a target="_blank" rel="noopener" href="https://www.antlr.org/">Antlr</a> 设计编程语言文法时，<code>&gt;</code> 符号作为大于号( <code>a &gt; 0</code> )、泛型尖括号( <code>List&lt;int&gt;</code> )、按位右移运算符( <code>a &gt;&gt; 1</code> )这些语义时碰到的问题。</p>
<h2 id="文法设计"><a href="#文法设计" class="headerlink" title="文法设计"></a>文法设计</h2><p>首先在词法上，一般会分开，把 <code>&lt;</code> <code>&gt;</code> 视为一个独立的 token，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Lexer grammar</span><br><span class="line">GREATER  : &#x27;&gt;&#x27; ;</span><br><span class="line">LESS     : &#x27;&lt;&#x27; ;</span><br></pre></td></tr></table></figure>

<p>接着是定义语法，一个一个来，先定义比较大小的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Parser grammar</span><br><span class="line">relation_expr: expression LESS expression</span><br><span class="line">              | expression GREATER expression</span><br><span class="line">              ;</span><br></pre></td></tr></table></figure>

<p>为了避免引入与本文无关的复杂性，这里先忽略其他操作符的优先级和结合性，以及引起左递归等问题，认为左值和右值都是表达式。</p>
<p>然后定义按位左移、右移的语法。这通常是两个大于号、小于号的组合。<br>可以参考按位与 <code>&amp;</code>、逻辑且 <code>&amp;&amp;</code> 的做法，把 <code>&gt;&gt;</code> <code>&lt;&lt;</code> 视为两个独立的 token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Lexer grammar</span><br><span class="line">SHIFT_LEFT  : &#x27;&lt;&lt;&#x27; ;</span><br><span class="line">SHIFT_RIGHT : &#x27;&gt;&gt;&#x27; ;</span><br></pre></td></tr></table></figure>

<p>对应的语法就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Parser grammar</span><br><span class="line">shift_expr: expression SHIFT_LEFT expression</span><br><span class="line">           | expression SHIFT_RIGHT expression</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure>

<p>看上去非常顺利，语法设计完成了。</p>
<p>但是，如果还要引入泛型语法，使用尖括号 <code>&lt;</code> <code>&gt;</code> 来表示类型参数，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Parser grammar</span><br><span class="line">generic_expr: expression LESS type_parameters GREATER;</span><br></pre></td></tr></table></figure>

<p>我们不关注 <code>type_parameters</code> 语法的具体定义，假设它可以<em>递归地</em>表达这个泛型类型的语法。</p>
<p><code>generic_expr</code> 已经能表达类似 <code>List&lt;int&gt;</code> 的泛型类型了。但通常，泛型的参数本身，还可以嵌套泛型，比如 <code>List&lt;List&lt;int&gt;&gt;</code>。这就导致了一些冲突：</p>
<p>词法分析结果：</p>
<p><code>List&lt;int&gt;</code> 被解释为下面几个 token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List     &lt;     int    &gt;</span><br><span class="line">LIST | LESS | INT | GREATER</span><br></pre></td></tr></table></figure>

<p>而 <code>List&lt;List&lt;int&gt;&gt;</code> 被解释为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List     &lt;    List    &lt;     int       &gt;       &gt;</span><br><span class="line">LIST | LESS | LIST | LESS | INT | GREATER | GREATER</span><br></pre></td></tr></table></figure>

<p>…吗？还记得 <code>SHIFT_RIGHT</code> 吗？它也是两个 <code>&gt;</code> 组成的 token。事实上，由于 Antlr 的词法分析是贪婪的，最后两个 token 会被合并为一个 <code>SHIFT_RIGHT</code>，导致词法分析结果变成了：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-  LIST | LESS | LIST | LESS | INT | GREATER | GREATER</span></span><br><span class="line"><span class="addition">+  LIST | LESS | LIST | LESS | INT | SHIFT_RIGHT</span></span><br></pre></td></tr></table></figure>

<p>词法分析的意外会进一步导致语法分析的崩溃：泛型语法应该以 <code>GREATER</code> 结尾，但现在是 <code>SHIFT_RIGHT</code> 结尾，这就造成了语法错误。</p>
<h2 id="尖括号的二义性"><a href="#尖括号的二义性" class="headerlink" title="尖括号的二义性"></a>尖括号的二义性</h2><p>有办法在词法分析时避免这种情况吗？答案是否定的——词法分析阶段，还没有完整 b 的分析出语法结构，更别说语义了。仅根据词法，难以区分 <code>&gt;</code> 是大于号还是泛型的结束。也就是说，与 <code>&amp;</code> 符号不同的是，<code>&gt;</code> 符号在语法上有多种意义，难以在词法上提前区分。</p>
<p>那么，问题出在右移的词法上。不应该声明两个大于号为一个 token，而是，在语法上，通过两个 <code>GREATER</code> 来表示右移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Parser grammar</span><br><span class="line">shift_expr: expression GREATER GREATER expression</span><br><span class="line">           | expression SHIFT_RIGHT expression</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure>

<p>不过左移的词法，如果从设计上不会出现其他的两个 <code>&lt;</code> 连续的情况，那就可以保留。</p>
<h2 id="从-js-到-ts-的做法"><a href="#从-js-到-ts-的做法" class="headerlink" title="从 js 到 ts 的做法"></a>从 js 到 ts 的做法</h2><p>我们知道 JavaScript 是没有类型语法的，更没有泛型。</p>
<p>在 JavaScript 的 <a target="_blank" rel="noopener" href="https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/javascript/javascript/JavaScriptLexer.g4#L83">antlr 词法文件</a>中，确实有 <code>&gt;&gt;</code> 作为独立 token 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeftShiftArithmetic        : &#x27;&lt;&lt;&#x27;;</span><br><span class="line">RightShiftArithmetic       : &#x27;&gt;&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>而在这门语言中扩展类型，升级到 TypeScript，就会碰到泛型问题，所以 TypeScript 的 <a target="_blank" rel="noopener" href="https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/javascript/typescript/TypeScriptLexer.g4#L83">antlr 词法文件</a>中，去掉了 <code>&gt;&gt;</code> 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeftShiftArithmetic        : &#x27;&lt;&lt;&#x27;;</span><br><span class="line">// We can&#x27;t match these in the lexer because it would cause issues when parsing</span><br><span class="line">// types like Map&lt;string, Map&lt;string, string&gt;&gt;</span><br><span class="line">// RightShiftArithmetic       : &#x27;&gt;&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="C-的做法"><a href="#C-的做法" class="headerlink" title="C++ 的做法"></a>C++ 的做法</h2><p>C++ 同样有泛型，也没有定义 <code>&gt;&gt;</code> 的 token，甚至连 <code>&lt;&lt;</code> 的 token 都没有。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/cpp/CPP14Lexer.g4#L228">https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/cpp/CPP14Lexer.g4#L228</a></p>
<h2 id="不用尖括号的泛型语法"><a href="#不用尖括号的泛型语法" class="headerlink" title="不用尖括号的泛型语法"></a>不用尖括号的泛型语法</h2><p>go 和 python 的泛型语法使用方括号 <code>[]</code>，避免了 <code>&gt;</code> 的歧义。因此，词法文件中声明了 <code>&gt;&gt;</code> 的 token</p>
<p><a target="_blank" rel="noopener" href="https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/python/python3/Python3Lexer.g4">https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/python/python3/Python3Lexer.g4</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/golang/GoLexer.g4">https://github.com/antlr/grammars-v4/blob/bdf2e9a5e618f54e7a2ad95610e314a199f10f77/golang/GoLexer.g4</a></p>
<h2 id="左移赋值语法的-token-设计"><a href="#左移赋值语法的-token-设计" class="headerlink" title="左移赋值语法的 token 设计"></a>左移赋值语法的 token 设计</h2><p>和尖括号有关的文法，还有两种，大于等于 <code>&gt;=</code>，和右移赋值 <code>&gt;&gt;=</code>。</p>
<p>假设我们现在有这些词法 token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Lexer grammar</span><br><span class="line">GREATER  : &#x27;&gt;&#x27; ;</span><br><span class="line">LESS     : &#x27;&lt;&#x27; ;</span><br><span class="line">GREATER_EQUAL : &#x27;&gt;=&#x27; ;</span><br></pre></td></tr></table></figure>

<p>那么，右移赋值的应该在词法上设计为完整的 token，还是在语法上拼接 GREATER 和 GREATER_EQUAL 呢？</p>
<p>后者有点奇怪，毕竟大于等于在语义上和前一个大于号没有什么关联。假设采用前者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RIGHT_SHIFT_ASSIGN : &#x27;&gt;&gt;=&#x27; ;</span><br></pre></td></tr></table></figure>

<p>这就有个问题，输入 <code>a &gt;&gt;= 1</code> 时，中间的部分，在词法分析阶段，是会被识别为 <code>GREATER GREATER_EQUAL</code>（大于号和大于等于号），还是 <code>RIGHT_SHIFT_ASSIGN</code>（右移赋值号）？在 antlr 中，答案是后者，antlr 会尝试匹配字符最长的 token。</p>
</div><div class="tags"><a href="/blog/tags/VS-Code/"><i class="fa fa-tag"></i>VS Code</a><a href="/blog/tags/antlr4/"><i class="fa fa-tag"></i>antlr4</a><a href="/blog/tags/antlr/"><i class="fa fa-tag"></i>antlr</a></div><div class="post-nav"><a class="next" href="/blog/2025/05/07/ts-go/">用 Go 移植 TypeScript 的重要影响</a></div><div class="giscus"></div><script src="https://giscus.app/client.js" data-repo="imbant/blog" data-repo-id="MDEwOlJlcG9zaXRvcnkyNDkzOTc0NDM=" data-category="General" data-category-id="DIC_kwDODt2Aw84Ch79K" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://imbant.github.io/blog"/></form></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><span id="footer-copyright">Copyright © </span><a href="/blog/." rel="nofollow">imbAnt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script>const tag = document.getElementById('footer-copyright');const year = new Date().getFullYear();tag.innerText += year + ' ';</script></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/blog/js/gifFavIcon.js"></script></div></body></html>